//
//	  Canonical Name		String Name			Operand Params				Code		Consts																					"name|category|main description|possible exception|stack transition|variant description"
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// NOTE: opcodes with name="" and params=0 still need to be defined

// Memory Load and Store instructions

nvmOPCODE(PBLDS,			"spload.8",			T_NO_ARG_INST,				0x00,		OP_TYPE_NTERM|OP_LOAD|MEM_PACKET|DIM_8|SIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store|Copy a value from a specified memory to the top of the stack. The value loaded is taken from an address popped out from the stack, so this instruction must be precedeed by a push instruction. In our architecture, the stack has only one data type (32bit), so when loading a different data type (8bit or 16bit) an appropriate conversion is needed (signed or unsigned). When loading a 32bit int no conversion is needed, regardless the sign of the value loaded|The stack is empty (i.e., no elements can be popped out from the stack); the address popped out is out of bounds of the memory segment| address -> value|Load a signed 8bit int from the packet buffer segment on the stack after conversion to a 32bit int")
nvmOPCODE(PBLDU,			"upload.8",			T_NO_ARG_INST,				0x01,		OP_TYPE_NTERM|OP_LOAD|MEM_PACKET|DIM_8|UNSIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load an unsigned 8bit int from the packet buffer segment on the stack after conversion to a 32bit int")
nvmOPCODE(PSLDS,			"spload.16",		T_NO_ARG_INST,				0x02,		OP_TYPE_NTERM|OP_LOAD|MEM_PACKET|DIM_16|SIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load a signed 16bit int from the packet memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(PSLDU,			"upload.16",		T_NO_ARG_INST,				0x03,		OP_TYPE_NTERM|OP_LOAD|MEM_PACKET|DIM_16|UNSIGNED|ONE_OP|ONE_DEF,						"load|Memory Load and Store||||Load an unsigned 16bit int from the packet memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(PILD,				"spload.32",		T_NO_ARG_INST,				0x04,		OP_TYPE_NTERM|OP_LOAD|MEM_PACKET|DIM_32|SIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load a 32bit int from the packet memory segment on the stack")
nvmOPCODE(DBLDS,			"smload.8",			T_NO_ARG_INST,				0x05,		OP_TYPE_NTERM|OP_LOAD|MEM_DATA|DIM_8|SIGNED|ONE_OP|ONE_DEF,								"load|Memory Load and Store||||Load a signed 8bit int from the data memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(DBLDU,			"umload.8",			T_NO_ARG_INST,				0x06,		OP_TYPE_NTERM|OP_LOAD|MEM_DATA|DIM_8|UNSIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load an unsigned 8bit int from the data memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(DSLDS,			"smload.16",		T_NO_ARG_INST,				0x07,		OP_TYPE_NTERM|OP_LOAD|MEM_DATA|DIM_16|SIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load a signed 16bit int from the data memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(DSLDU,			"umload.16",		T_NO_ARG_INST,				0x08,		OP_TYPE_NTERM|OP_LOAD|MEM_DATA|DIM_16|UNSIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load an unsigned 16bit int from the data memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(DILD,				"umload.32",		T_NO_ARG_INST,				0x09,		OP_TYPE_NTERM|OP_LOAD|MEM_DATA|DIM_32|UNSIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load a 32bit int from the packet data segment on the stack")
nvmOPCODE(SBLDS,			"ssload.8",			T_NO_ARG_INST,				0x46,		OP_TYPE_NTERM|OP_LOAD|MEM_SHARED|DIM_8|SIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load a signed 8bit int from the shared memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(SBLDU,			"usload.8",			T_NO_ARG_INST,				0x47,		OP_TYPE_NTERM|OP_LOAD|MEM_SHARED|DIM_8|UNSIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load an unsigned 8bit int from the packet buffer segment on the stack after conversion to a 32bit int")
nvmOPCODE(SSLDS,			"ssload.16",		T_NO_ARG_INST,				0x48,		OP_TYPE_NTERM|OP_LOAD|MEM_SHARED|DIM_16|SIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load a signed 16bit int from the shared memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(SSLDU,			"usload.16",		T_NO_ARG_INST,				0x49,		OP_TYPE_NTERM|OP_LOAD|MEM_SHARED|DIM_16|UNSIGNED|ONE_OP|ONE_DEF,						"load|Memory Load and Store||||Load an unsigned 16bit int from the shared memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(SILD,				"ssload.32",		T_NO_ARG_INST,				0x4a,		OP_TYPE_NTERM|OP_LOAD|MEM_SHARED|DIM_32|SIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load a 32bit int from the shared memory segment on the stack")
//nvmOPCODE(BPLOAD_IH,		"iplen",			T_NO_ARG_INST,				0x0f,		OP_TYPE_STMT|OP_IPLEN|ONE_OP|ONE_DEF,													"iplen|Memory Load and Store|Load a byte from the packet memory, masks it with the 0x0f constant and multiplies it for 4. Can be used to calculate the lenght of an IP header|||")
nvmOPCODE(DBSTR,			"mstore.8",			T_NO_ARG_INST,				0x10,		OP_TYPE_STMT|OP_STORE|MEM_DATA|DIM_8|SIGNED|TWO_OPS|NO_DEF,								"store|Memory Load and Store|The value on the top of the stack is popped out and stored in the appropriate memory segment, at an address popped from the stack as well. Like the load instruction, when storing a 32bit int there's no difference from signed and unsigned (the value on the stack is already a 32bit int); when storing a 8bit int or a 16bit int, a conversion is needed before storing the value on the memory segment (the conversion will be different if the value has to be considered signed or unsigned).The value is transformed in the apposite format (network-byte order or host-byte order) before the store.|The stack is empty (i.e., no elements can be popped out from the stack); the address is out of bounds of the memory segment| address, value -> (none)|Store a 8bit int from the stack to data memory after conversion from a 32bit int")
nvmOPCODE(DSSTR,			"mstore.16",		T_NO_ARG_INST,				0x12,		OP_TYPE_STMT|OP_STORE|MEM_DATA|DIM_16|SIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store a 16bit int from the stack to data memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(DISTR,			"mstore.32",		T_NO_ARG_INST,				0x14,		OP_TYPE_STMT|OP_STORE|MEM_DATA|DIM_32|SIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store a 32bit int from the stack to data memory")
nvmOPCODE(PBSTR,			"pstore.8",			T_NO_ARG_INST,				0x15,		OP_TYPE_STMT|OP_STORE|MEM_PACKET|DIM_8|SIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store an 8bit int from the stack to packet memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(PSSTR,			"pstore.16",		T_NO_ARG_INST,				0x18,		OP_TYPE_STMT|OP_STORE|MEM_PACKET|DIM_16|SIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store a 16bit int from the stack to packet memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(PISTR,			"pstore.32",		T_NO_ARG_INST,				0x19,		OP_TYPE_STMT|OP_STORE|MEM_PACKET|DIM_32|SIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store a 32bit int from the stack to packet memory")
nvmOPCODE(SBSTR,			"sstore.8",			T_NO_ARG_INST,				0x4c,		OP_TYPE_STMT|OP_STORE|MEM_SHARED|DIM_8|SIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store an 8bit int from the stack to shared memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(SSSTR,			"sstore.16",		T_NO_ARG_INST,				0x4d,		OP_TYPE_STMT|OP_STORE|MEM_SHARED|DIM_16|SIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store a 16bit int from the stack to shared memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(SISTR,			"sstore.32",		T_NO_ARG_INST,				0x4f,		OP_TYPE_STMT|OP_STORE|MEM_SHARED|DIM_32|SIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store a 32bit int from the stack to shared memory")


// Memory Load and Store

nvmOPCODE(IBSTR,			"istore.8",			T_NO_ARG_INST,				0xf0,		OP_TYPE_STMT|OP_STORE|MEM_INFO|DIM_8|UNSIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store an 8bit int from the stack to the info memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(ISSTR,			"istore.16",		T_NO_ARG_INST,				0xf1,		OP_TYPE_STMT|OP_STORE|MEM_INFO|DIM_16|UNSIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store a 16bit int from the stack to the info memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(IISTR,			"istore.32",		T_NO_ARG_INST,				0xf2,		OP_TYPE_STMT|OP_STORE|MEM_INFO|DIM_32|UNSIGNED|TWO_OPS|NO_DEF,							"store|Memory Load and Store||||Store a 32bit int from the stack to the info memory")
nvmOPCODE(ISBLD,			"uiload.8",			T_NO_ARG_INST,				0xf3,		OP_TYPE_NTERM|OP_LOAD|MEM_INFO|DIM_8|UNSIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load an unsigned 8bit int from the info memory on the stack after conversion to a 32bit int")
nvmOPCODE(ISSLD,			"uiload.16",		T_NO_ARG_INST,				0xf4,		OP_TYPE_NTERM|OP_LOAD|MEM_INFO|DIM_16|UNSIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load an unsigned 16bit int from the info memory on the stack after conversion to a 32bit int")
nvmOPCODE(ISSBLD,			"siload.8",			T_NO_ARG_INST,				0xf5,		OP_TYPE_NTERM|OP_LOAD|MEM_INFO|DIM_8|SIGNED|ONE_OP|ONE_DEF,								"load|Memory Load and Store||||Load a signed 8bit int from the info memory on the stack after conversion to a 32bit int")
nvmOPCODE(ISSSLD,			"siload.16",		T_NO_ARG_INST,				0xf6,		OP_TYPE_NTERM|OP_LOAD|MEM_INFO|DIM_16|SIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load a signed 16bit int from the info memory on the stack after conversion to a 32bit int")
nvmOPCODE(ISSILD,			"siload.32",		T_NO_ARG_INST,				0xf7,		OP_TYPE_NTERM|OP_LOAD|MEM_INFO|DIM_32|SIGNED|ONE_OP|ONE_DEF,							"load|Memory Load and Store||||Load a signed 32bit int from the info memory on the stack")



// Arithmetic instructions

nvmOPCODE(ADD,				"add",				T_NO_ARG_INST,				0x20,		OP_TYPE_NTERM|OP_ARITH|ARITH_ADD|UNSIGNED|TWO_OPS|ONE_DEF,								"add|Arithmetic and logic|Addition of the top two items of the stack|The stack is empty (i.e., no elements can be popped out from the stack); Arithmetic overflow or underflow|value1, value2 -> result|Addition of the two top items of the stack without overflow control")
nvmOPCODE(ADDSOV,			"add.s",			T_NO_ARG_INST,				0x21,		OP_TYPE_NTERM|OP_ARITH|ARITH_ADD|SIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"add|Arithmetic and logic||||Addition of the two top items of the stack considered as signed 32bit int with overflow control")
nvmOPCODE(ADDUOV,			"add.u",			T_NO_ARG_INST,				0x22,		OP_TYPE_NTERM|OP_ARITH|ARITH_ADD|UNSIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"add|Arithmetic and logic||||Addition of the two top items of the stack considered as unsigned 32bit int with overflow control")
nvmOPCODE(SUB,				"sub",				T_NO_ARG_INST,				0x23,		OP_TYPE_NTERM|OP_ARITH|ARITH_SUB|UNSIGNED|TWO_OPS|ONE_DEF,								"sub|Arithmetic and logic|Subtraction of the first value popped from the stack to the second value|The stack is empty (i.e., no elements can be popped out from the stack); Arithmetic overflow or underflow|value1, value2 -> result|Subtraction the first value on the stack to the second one without overflow control")
nvmOPCODE(SUBSOV,			"sub.s",			T_NO_ARG_INST,				0x24,		OP_TYPE_NTERM|OP_ARITH|ARITH_SUB|SIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"sub|Arithmetic and logic||||Subtraction the first value on the stack to the second one considered as signed 32bit with overflow control")
nvmOPCODE(SUBUOV,			"sub.u",			T_NO_ARG_INST,				0x25,		OP_TYPE_NTERM|OP_ARITH|ARITH_SUB|UNSIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"sub|Arithmetic and logic||||Subtraction the first value on the stack to the second one considered as unsigned 32bit with overflow control")
nvmOPCODE(IMUL,				"mul",				T_NO_ARG_INST,				0x26,		OP_TYPE_NTERM|OP_ARITH|ARITH_MUL|UNSIGNED|TWO_OPS|ONE_DEF,								"mul|Arithmetic and logic|Multiplication of the first two values on the stack |The stack is empty (i.e., no elements can be popped out from the stack); Arithmetic overflow or underflow|value1, value2 -> result|Multiplication of the first two values on the stack without overflow control")
nvmOPCODE(IMULSOV,			"mul.s",			T_NO_ARG_INST,				0x27,		OP_TYPE_NTERM|OP_ARITH|ARITH_MUL|SIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"mul|Arithmetic and logic||||Multiplication of the first two values on the stack considered as signed 32bit with overflow control")
nvmOPCODE(IMULUOV,			"mul.u",			T_NO_ARG_INST,				0x28,		OP_TYPE_NTERM|OP_ARITH|ARITH_MUL|UNSIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"mul|Arithmetic and logic||||Multiplication of the first two values on the stack considered as unsigned 32bit with overflow control")

nvmOPCODE(MOD,				"mod",				T_NO_ARG_INST,				0x3f,		OP_TYPE_NTERM|OP_ARITH|ARITH_MOD|TWO_OPS|ONE_DEF,										"mod|Arithmetic and logic|Modulus of the first two values on the stack considered as unsigned 32bit|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 -> result|Modulus of the first two values on the stack without overflow control")

nvmOPCODE(NEG,				"neg",				T_NO_ARG_INST,				0x29,		OP_TYPE_NTERM|OP_ARITH|ARITH_NEG|ONE_OP|ONE_DEF,										"neg|Arithmetic and logic|2's complement of the first value on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value -> result|arithmetic negation of the topmost element of the stack")
nvmOPCODE(OR,				"or",				T_NO_ARG_INST,				0x2a,		OP_TYPE_NTERM|OP_ARITH|ARITH_OR|TWO_OPS|ONE_DEF,										"or|Arithmetic and logic|Bitwise OR of the first two values on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 -> result|Bitwise OR of the first two values of the stack")
nvmOPCODE(AND,				"and",				T_NO_ARG_INST,				0x2b,		OP_TYPE_NTERM|OP_ARITH|ARITH_AND|TWO_OPS|ONE_DEF,										"and|Arithmetic and logic|Bitwise AND of the first two values on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 -> result|Bitwise AND of the first two values of the stack")
nvmOPCODE(XOR,				"xor",				T_NO_ARG_INST,				0x2c,		OP_TYPE_NTERM|OP_ARITH|ARITH_XOR|ONE_OP|ONE_DEF,										"xor|Arithmetic and logic|Bitwise XOR of the first two values on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 -> result|Bitwise XOR of the first two values of the stack")
nvmOPCODE(NOT,				"not",				T_NO_ARG_INST,				0x3e,		OP_TYPE_NTERM|OP_ARITH|ARITH_NOT|ONE_OP|ONE_DEF,										"not|Arithmetic and logic|1's complement (bitwise NOT) of the first value on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value -> result|Bitwise NOT of the first value of the stack")
nvmOPCODE(IINC_1,			"inc",				T_NO_ARG_INST,				0x2d,		OP_TYPE_NTERM|OP_ARITH|ARITH_IINC_1|ONE_OP|ONE_DEF,										"inc|Arithmetic and logic|Increment of the value of an element on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value -> result|Increment the topmost element of the stack")
//nvmOPCODE(IINC_2,			"inc2",				T_NO_ARG_INST,				0x2e,		OP_TYPE_NTERM|OP_ARITH|ARITH_IINC_2|ONE_OP|ONE_DEF,										"inc|Arithmetic and logic||||Increment the 2nd element of the stack")
//nvmOPCODE(IINC_3,			"inc3",				T_NO_ARG_INST,				0x2f,		OP_TYPE_NTERM|OP_ARITH|ARITH_IINC_3|ONE_OP|ONE_DEF,										"inc|Arithmetic and logic||||Increment the 3rd element of the stack")
//nvmOPCODE(IINC_4,			"inc4",				T_NO_ARG_INST,				0xea,		OP_TYPE_NTERM|OP_ARITH|ARITH_IINC_4|ONE_OP|ONE_DEF,										"inc|Arithmetic and logic||||Increment the 4th element of the stack")
nvmOPCODE(IDEC_1,			"dec",				T_NO_ARG_INST,				0xeb,		OP_TYPE_NTERM|OP_ARITH|ARITH_IDEC_1|ONE_OP|ONE_DEF,										"dec|Arithmetic and logic|Decrement of the value of an element on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value -> result|Decrement the topmost element of the stack")
//nvmOPCODE(IDEC_2,			"dec2",				T_NO_ARG_INST,				0xec,		OP_TYPE_NTERM|OP_ARITH|ARITH_IDEC_2|ONE_OP|ONE_DEF,										"dec|Arithmetic and logic||||Decrement the 2nd element of the stack")
//nvmOPCODE(IDEC_3,			"dec3",				T_NO_ARG_INST,				0xed,		OP_TYPE_NTERM|OP_ARITH|ARITH_IDEC_3|ONE_OP|ONE_DEF,										"dec|Arithmetic and logic||||Decrement the 3rd element of the stack")
//nvmOPCODE(IDEC_4,			"dec4",				T_NO_ARG_INST,				0x30,		OP_TYPE_NTERM|OP_ARITH|ARITH_IDEC_4|ONE_OP|ONE_DEF,										"dec|Arithmetic and logic||||Decrement the 4th element of the stack")
nvmOPCODE(SHL,				"shl",				T_NO_ARG_INST,				0x31,		OP_TYPE_NTERM|OP_ARITH|ARITH_SHL|TWO_OPS|ONE_DEF,										"shl|Arithmetic and logic|Arithmetical left shift|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 -> result|The vacated right bits are set to 0. This instruction performs the moltiplication of value 2 by 2^value1 for signed integers. The result is unpredicted if the right operand is greater than or equal to the width in bits of the promoted left operand.")
nvmOPCODE(SHR,				"shr",				T_NO_ARG_INST,				0x32,		OP_TYPE_NTERM|OP_ARITH|ARITH_SHR|TWO_OPS|ONE_DEF,										"shr|Arithmetic and logic|Arithmetical right shift of the second element on the stack of a number of position popped from the top of the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 -> result|The vacated left bits are filled with copies of the sign bit. This instruction performs the division of value2 by 2^value1 for signed integers")
nvmOPCODE(USHR,				"ushr",				T_NO_ARG_INST,				0x34,		OP_TYPE_NTERM|OP_ARITH|ARITH_USHR|TWO_OPS|ONE_DEF,										"ushr|Arithmetic and logic|Logical right shift of the second element on the stack of a number of position popped from the top of the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 -> result|The vacated left bits are set to 0. This instruction performs the division of value2 by 2^value1 for unsigned integers")
//nvmOPCODE(IRND,				"rnd",				T_NO_ARG_INST,				0x35,		OP_TYPE_NTERM|OP_ARITH|ARITH_IRND|NO_OPS|ONE_DEF,										"rnd|Arithmetic and logic|Puts a random integer on the stack|none|(none) -> result|")
nvmOPCODE(CMP,				"cmp",				T_NO_ARG_INST,				0x36,		OP_TYPE_NTERM|OP_ARITH|ARITH_CMP|TWO_OPS|ONE_DEF,										"cmp|Arithmetic and logic|A comparison is done between the first two elements on the stack. If necessary, the values are previously masked by a value popped out from the stack as well. If value1 is equal to value2, the constant 0 will be pushed on the stack; if value1 is greater than value2, the constant 1 will be pushed on the stack; if value1 is lower than value2, the constant -1 will be pushed on the stack.|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2, (mask) -> result|Compares the first two items on the stack")
nvmOPCODE(MCMP,				"mcmp",				T_NO_ARG_INST,				0x37,		OP_TYPE_NTERM|OP_ARITH|ARITH_MCMP|TWO_OPS|ONE_DEF,										"cmp|Arithmetic and logic||||Performs a masked comparison between the first two elements n the stack. The mask is on the stack as well.")
nvmOPCODE(JCMPEQ,			"jcmp.eq",			T_1LABEL_INST,				0x38,		OP_TYPE_STMT|OP_JUMP|CND_EQ|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,				"jcmp|Flow control|Comparison between the first two items of the stack. If the test succeeds, a the program execution continues with the instruction following &lt;label&gt;.|The stack is empty (i.e., no elements can be popped out from the stack); the branch is out of bounds of the code memory segment|value1, value2 -> (none) |Branch if the first element on the stack is equal to the second one")
nvmOPCODE(JCMPNEQ,			"jcmp.neq",			T_1LABEL_INST,				0x39,		OP_TYPE_STMT|OP_JUMP|CND_NEQ|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,			"jcmp|Flow control||||Branch if the first element on the stack is not equal to the second one")
nvmOPCODE(JCMPG,			"jcmp.g",			T_1LABEL_INST,				0x3a,		OP_TYPE_STMT|OP_JUMP|CND_G|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,				"jcmp|Flow control||||Branch if the first element on the stack is greater than the second one")
nvmOPCODE(JCMPGE,			"jcmp.ge",			T_1LABEL_INST,				0x3b,		OP_TYPE_STMT|OP_JUMP|CND_GE|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,				"jcmp|Flow control||||Branch if the first element on the stack is greater than or equal to the second one")
nvmOPCODE(JCMPL,			"jcmp.l",			T_1LABEL_INST,				0x3c,		OP_TYPE_STMT|OP_JUMP|CND_L|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,				"jcmp|Flow control||||Branch if the first element on the stack is lower than the second one")
nvmOPCODE(JCMPLE,			"jcmp.le",			T_1LABEL_INST,				0x3d,		OP_TYPE_STMT|OP_JUMP|CND_LE|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,				"jcmp|Flow control||||Branch if the first element on the stack is lower than or equal to the second one")
nvmOPCODE(JCMPG_S,			"jcmp.gts",			T_1LABEL_INST,				0xc0,		OP_TYPE_STMT|OP_JUMP|CND_G|SIGNED|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,		"jcmp|Flow control||||Branch if the first element on the stack is greater than the second one, considering both elements as signed int")
nvmOPCODE(JCMPGE_S,			"jcmp.ges",			T_1LABEL_INST,				0xc1,		OP_TYPE_STMT|OP_JUMP|CND_GE|SIGNED|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,		"jcmp|Flow control||||Branch if the first element on the stack is equal to or greater than the second one, considering both elements as signed int")
nvmOPCODE(JCMPL_S,			"jcmp.lts",			T_1LABEL_INST,				0xc2,		OP_TYPE_STMT|OP_JUMP|CND_L|SIGNED|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,		"jcmp|Flow control||||Branch if the first element on the stack is lower than the second one, considering both elements as signed int")
nvmOPCODE(JCMPLE_S,			"jcmp.les",			T_1LABEL_INST,				0xc3,		OP_TYPE_STMT|OP_JUMP|CND_LE|SIGNED|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,		"jcmp|Flow control||||Branch if the first element on the stack is equal to or lower than the second one, considering both elements as signed int")
nvmOPCODE(CMP_S,			"cmp.s",			T_1LABEL_INST,				0xc4,		OP_TYPE_NTERM|OP_ARITH|ARITH_CMP|SIGNED|TWO_OPS|ONE_DEF,								"cmp|Arithmetic and logic||||Masked comparison between the two top items of the stack")
nvmOPCODE(ROTL,				"rol",				T_NO_ARG_INST,				0x44,		OP_TYPE_NTERM|OP_ARITH|ARITH_ROTL|TWO_OPS|ONE_DEF,										"rol|Arithmetic and logic|Rotate to the left the bits of the second element on the stack of a number of bits specified on the top of the stack |The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 -> result|Value1 is rotated of a number of bits specified by value 2")
nvmOPCODE(ROTR,				"ror",				T_NO_ARG_INST,				0x45,		OP_TYPE_NTERM|OP_ARITH|ARITH_ROTR|TWO_OPS|ONE_DEF,										"ror|Arithmetic and logic|Rotate to the right the bits of the second element on the stack of a number of bits specified on the top of the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 -> result|Value1 is rotated of a number of bits specified by value 2")

// Stack management instructions (check PUSH2, DUP, SWAP, IESWAP)

nvmOPCODE(PUSH,				"push",				T_1INT_ARG_INST,			0x50,		OP_TYPE_NTERM|OP_STACK|STK_PUSH|NO_OPS|ONE_DEF,											"push|Stack management|Push a constant value on the stack|The stack is full (No elements can be pushed on the stack)|(none) value|Push a constant value on the stack")
//nvmOPCODE(PUSH2,			"push2",			T_2INT_ARG_INST,			0x51,		OP_TYPE_NTERM|OP_STACK|STK_PUSH2|TWO_OPS|ONE_DEF,										"push2|Stack management|Push two constant values on the stack|The stack is full (No elements can be pushed on the stack)|(none) value, value|Push two constant values on the stack")
nvmOPCODE(POP,				"pop",				T_NO_ARG_INST,				0x52,		OP_TYPE_NTERM|OP_STACK|STK_POP|NO_OPS|NO_DEF,											"pop|Stack management|Deletion of the first value(s) of the stack.|The stack is empty (i.e., no elements can be popped out from the stack)| value -> (none) |Remove the top of the stack")
//nvmOPCODE(POP_I,			"popi",				T_1BYTE_ARG_INST,			0x53,		OP_TYPE_NTERM|OP_STACK|STK_POP_I|NO_OPS|NO_DEF,											"pop|Stack management||||Deletes the first i values of the stack, where i is the paramenter of the instruction")
nvmOPCODE(CONST_1,			"push_1",			T_NO_ARG_INST,				0x54,		OP_TYPE_NTERM|OP_STACK|STK_CONST_1|NO_OPS|ONE_DEF,										"push|Stack management||||Push the constant 1 on the stack")
nvmOPCODE(CONST_2,			"push_2",			T_NO_ARG_INST,				0x55,		OP_TYPE_NTERM|OP_STACK|STK_CONST_2|NO_OPS|ONE_DEF,										"push|Stack management||||Push the constant 2 on the stack")
nvmOPCODE(CONST_0,			"push_0",			T_NO_ARG_INST,				0x56,		OP_TYPE_NTERM|OP_STACK|STK_CONST_0|NO_OPS|ONE_DEF,										"push|Stack management||||Push the constant 0 on the stack")
nvmOPCODE(CONST__1,			"push__1",			T_NO_ARG_INST,				0x57,		OP_TYPE_NTERM|OP_STACK|STK_CONST__1|NO_OPS|ONE_DEF,										"push|Stack management||||Push the constant -1 on the stack")

nvmOPCODE(DUP,				"dup",				T_NO_ARG_INST,				0x5a,		OP_TYPE_NTERM|OP_STACK|STK_DUP|ONE_OP|ONE_DEF,											"dup|Stack management|Duplicate the top operand stack value|The stack is full (No more elements can be pushed on the stack)|value -> value, value|")
nvmOPCODE(SWAP,				"swap",				T_NO_ARG_INST,				0x5c,		OP_TYPE_NTERM|OP_STACK|STK_SWAP|TWO_OPS|ONE_DEF,										"swap|Stack management|Exchange the top two elements of the stack|none?|value1, value2 -> value2, value1|")

// Flow control instructions (check SWITCH)

nvmOPCODE(JEQ,				"j.eq",				T_1LABEL_INST,				0x60,		OP_TYPE_STMT|OP_JUMP|JMP_JUMP|CND_EQ|JMPOPS_0|ONE_OP|JMPTGT_TWO_TARGETS|NO_DEF,			"j|Flow control|Comparison between the first item on the top of the stack and 0. If test is satisfied, the execution continues at the instruction following &lt;label&gt;|The stack is empty (i.e., no elements can be popped out from the stack); the branch is out of bounds of the code memory segment| value -> (none)|Branch if the top of the stack is equal to 0")
nvmOPCODE(JNE,				"j.ne",				T_1LABEL_INST,				0x61,		OP_TYPE_STMT|OP_JUMP|JMP_JUMP|CND_NEQ|JMPOPS_0|ONE_OP|JMPTGT_TWO_TARGETS|NO_DEF,		"j|Flow control||||Branch if the top of the stack is not equal to 0")
nvmOPCODE(JUMP,				"jump",				T_1_SHORT_LABEL_INST,		0x67,		OP_TYPE_STMT|OP_JUMP|JMP_JUMP|NO_OPS|NO_DEF|JMPTGT_ONE_TARGET,							"jump|Flow control|Unconditional branch|The branch is out of bounds of the code memory segment| (none) |Unconditional branch")
nvmOPCODE(JUMPW,			"jump.w",			T_1LABEL_INST,				0x68,		OP_TYPE_STMT|OP_JUMP|JMP_JUMP|WIDE|NO_OPS|NO_DEF|JMPTGT_ONE_TARGET,						"jump|Flow control||||Unconditional branch (wide index)")
nvmOPCODE(SWITCH,			"switch",			T_JMP_TBL_LKUP_INST,		0x6f,		OP_TYPE_STMT|OP_JUMP|JMP_SWITCH|JMPTGT_SWITCH|ONE_OP,									"switch|Flow control|Switch-Case construct. The first argument represents the number of cases, then follows a sequence of value:target pairs, representing the case values and the corresponding target labels. Last argument is the default target label|The stack is empty (i.e., no elements can be popped out from the stack)|value -> (none)|Compares the top of the stack with the values specified in the cases list, if a match is found, jumps to the label specified by the selected case. If no match is found, jumps to the label specified by the default case")
nvmOPCODE(CALL,				"call",				T_1LABEL_INST,				0x69,		OP_TYPE_STMT|OP_JUMP|JMP_CALL|ONE_OP|NO_DEF|JMPTGT_ONE_TARGET,							"call|Flow control|Call a subroutine. Some parameters can be pushed on the stack before the instruction, they are used as parameters for the subroutine, the parameters are popped from the procedure and the return value result is pushed on the stack|none| (value1), (value 2), (...), (value n) -> (result)|Call a subroutine")
nvmOPCODE(CALLW,			"call.w",			T_1LABEL_INST,				0x6a,		OP_TYPE_STMT|OP_JUMP|JMP_CALL|WIDE|ONE_OP|NO_DEF|JMPTGT_ONE_TARGET,						"call|Flow control||||Call a subroutine (wide index)")
nvmOPCODE(RET,				"ret",				T_NO_ARG_INST,				0x6b,		OP_TYPE_STMT|OP_JUMP|JMP_RET|NO_OPS|NO_DEF|JMPTGT_NO_TARGETS,							"ret|Flow control|Returns from a subroutine or from a section|none|(none)|No elements are pushed on or popped from the stack")


//field comparison branch instructions
nvmOPCODE(JFLDEQ,			"jfield.eq",		T_1LABEL_INST,				0x70,		OP_TYPE_STMT|OP_PTNMTC|PTNMTC_JFLD|CND_EQ|TWO_OPS|NO_DEF,								"jfield|Field Comparison and branch|Comparison between two fields in the packet buffer. If the test succeeds, a branch will occur. The argument is the label where to jump if the test succeeds|The stack is empty (i.e., no elements can be popped out from the stack); the branch is out of bounds of the code memory segment|offs_field1, offs_field2, len -> (none) |Compare two fields at different offsets in the packet memory, the offsets and the length are on the top of the stack. Branch if they are equal")
nvmOPCODE(JFLDNEQ,			"jfield.ne",		T_1LABEL_INST,				0x71,		OP_TYPE_STMT|OP_PTNMTC|PTNMTC_JFLD|CND_NE|TWO_OPS|NO_DEF,								"jfield|Field Comparison and branch||||Compare two fields at different offsets in the packet memory, the offsets and the length are on the top of the stack. Branch if they are not equal")
nvmOPCODE(JFLDLT,			"jfield.lt",		T_1LABEL_INST,				0x72,		OP_TYPE_STMT|OP_PTNMTC|PTNMTC_JFLD|CND_L|TWO_OPS|NO_DEF,								"jfield|Field Comparison and branch||||Compare two fields at different offsets in the packet memory, the offsets and the length are on the top of the stack. Branch if the first is lexicographically less than the second")
nvmOPCODE(JFLDGT,			"jfield.gt",		T_1LABEL_INST,				0x73,		OP_TYPE_STMT|OP_PTNMTC|PTNMTC_JFLD|CND_G|TWO_OPS|NO_DEF,								"jfield|Field Comparison and branch||||Compare two fields at different offsets in the packet memory, the offsets and the length are on the top of the stack. Branch if the first is lexicographically greater than the second")


nvmOPCODE(DPMCPY,			"dpcopy",			T_NO_ARG_INST,				0xa7,		OP_TYPE_STMT|OP_PKT|PKT_DPMCPY|NO_DEF,													"copy|Buffer Copy|Copy a memory buffer from one memory to another. Value1 must contain a valid offset inside the source memory, value2 must contain a valid offset inside the destination memory, value3 must contain the length of the buffer to be copied.|The stack is empty (i.e., no elements can be popped out from the stack); the first address is out of the source memory boundaries; the second address is out of destination memory boundaries| value1, value2, value3 -> (none) |Copy a memory buffer from data memory to packet buffer")
nvmOPCODE(PDMCPY,			"pdcopy",			T_NO_ARG_INST,				0xa8,		OP_TYPE_STMT|OP_PKT|PKT_PDMCPY|NO_DEF,													"copy|Buffer Copy||||Copy a memory buffer from packet buffer to data memory")
nvmOPCODE(DSMCPY,			"dscopy",			T_NO_ARG_INST,				0xa9,		OP_TYPE_STMT|OP_PKT|PKT_DSMCPY|NO_DEF,													"copy|Buffer Copy||||Copy a memory buffer from data memory to shared memory")
nvmOPCODE(SDMCPY,			"sdcopy",			T_NO_ARG_INST,				0xaa,		OP_TYPE_STMT|OP_PKT|PKT_SDMCPY|NO_DEF,													"copy|Buffer Copy||||Copy a memory buffer from shared memory to data memory")
nvmOPCODE(SPMCPY,			"spcopy",			T_NO_ARG_INST,				0xab,		OP_TYPE_STMT|OP_PKT|PKT_SPMCPY|NO_DEF,													"copy|Buffer Copy||||Copy a memory buffer from shared memory to packet buffer")
nvmOPCODE(PSMCPY,			"pscopy",			T_NO_ARG_INST,				0xac,		OP_TYPE_STMT|OP_PKT|PKT_PSMCPY|NO_DEF,													"copy|Buffer Copy||||Copy a memory buffer from packet buffer to shared memory")
nvmOPCODE(IPMCPY,			"ipcopy",			T_NO_ARG_INST,				0xbd,		OP_TYPE_STMT|OP_PKT|PKT_PIMCPY|NO_DEF,													"copy|Buffer Copy||||Copy a memory buffer from initialised data to packet buffer")


// Packet and data transfer instructions 
nvmOPCODE(SNDPKT,			"pkt.send",			T_1_PUSH_PORT_ARG_INST,		0xa4,		OP_TYPE_STMT|OP_PKT|PKT_SNDPKT|NO_OPS|NO_DEF,											"pkt.send|Packet and data transfer|Sends the current exchange buffer (valid only for push handlers)|none|(none)|Sends the current exchange buffer to a push-output port")
nvmOPCODE(DSNDPKT,			"pkt.senddup",		T_1_PUSH_PORT_ARG_INST,		0xb1,		OP_TYPE_STMT|OP_PKT|PKT_DSNDPKT|ONE_OP|NO_DEF,											"pkt.senddup|Packet and data transfer|Sends a copy of the current exchange buffer(valid only for push handlers)|none|(none)|Sends a copy of the current exchange buffer to a push-output port")
nvmOPCODE(RCVPKT,			"pkt.receive",		T_1_PULL_PORT_ARG_INST,		0xa5,		OP_TYPE_STMT|OP_PKT|PKT_RCVPKT|ONE_OP|NO_DEF,											"pkt.receive|Packet and data transfer|Receives the exchange buffer (valid only for pull handlers)|none|(none)|Receives the exchange buffer from a pull-input port")

nvmOPCODE(CRTEXBUF,			"exbuf.create",		T_NO_ARG_INST,				0xad,		OP_TYPE_STMT|OP_PKT|PKT_CRTEXBUF|ONE_OP|NO_DEF,											"exbuf.create|Packet and data transfer|Creates an exchange buffer (valid only for pull handlers)|The stack is empty (i.e., no elements can be popped out from the stack)| value ---> (none)| Create an Exchange Buffer whose size is passed through the stack")
nvmOPCODE(DELEXBUF,			"exbuf.delete",		T_NO_ARG_INST,				0xae,		OP_TYPE_STMT|OP_PKT|PKT_DELEXBUF|ONE_OP|NO_DEF,											"exbuf.delete|Packet and data transfer|Deletes the current exchange buffer (valid only for pull handlers)|none| (none) |Deletes the current exchange buffer")


// Control processing instructions

//!! nvmOPCODE(SCHTIMER,	,					,							0xaf,																								"Schedules a timer event that will asynchronously activate the current NetVM instance")

// Initialization instructions

// These opcodes have been removed
//nvmOPCODE(SDMSIZE,		"set.mem",			T_1INT_ARG_INST,			0xb0,		OP_TYPE_STMT|OP_INIT|INIT_SDMSIZE,														"set|Initialization|The size is passed by as a parameter (the parameter is a 8bit int). If size == 0 no memory is required. If size == -1 all physical memory available is required.|Failure in the memory allocation (if malloc returns a NULL pointer)| (none) |Set the size of the data memory")
//nvmOPCODE(SSMSIZE,			"set.share",		T_1INT_ARG_INST,			0xb5,		OP_TYPE_STMT|OP_INIT|INIT_SSMSIZE,														"set|Initialization|The size is passed by as a parameter (the parameter is a 8bit int). If size == 0 no memory is required. If size == -1 all physical memory available is required.|Failure in the memory allocation (if malloc returns a NULL pointer)| (none) |Set the size of the shared memory")
//nvmOPCODE(LOADE,			"loade",			T_1INT_ARG_INST,			0xb6,		OP_TYPE_NTERM|OP_INIT|INIT_LOADE,														"loade|Initialization|Load an exception table entry on the stack. The index of the entry to push on the stack is passed by as a parameter|The stack is not allocated; the stack is full (no elements can be pushed on the stack).|... -> ... - entry|")
//nvmOPCODE(STOREE,			"storee",			T_1INT_ARG_INST,			0xb7,		OP_TYPE_STMT|OP_INIT|INIT_STOREE,														"storee|Initialization|Store the top of the stack to an exception table entry. The parameter is the index in the Exception Table where to store the entry popped out from the stack|The stack is not allocated; the stack is empty (i.e., no elements can be popped out from the stack)|... - entry -> ...|")
//!! nvmOPCODE(LOADV,		,					,							0xb8,																								"Load a VNIC table entry on the stack")
//!! nvmOPCODE(SPKTOFF,	,					,								0xb9,																								"Set the offset in the packet memory at which an incoming packet will be put")

// Miscellaneous nvmOPCODEs

nvmOPCODE(NOP,				"nop",				T_NO_ARG_INST,				0xd7,		OP_TYPE_STMT|OP_MISC|MISC_NOP,															"nop|Miscellaneous|Performs no operations|none| (none) |No operation")
//nvmOPCODE(BRKPOINT,			"break",			T_NO_ARG_INST,				0xd8,		OP_TYPE_STMT|OP_MISC|MISC_BRKPOINT,														"break|Miscellaneous||||Used for debugging purposes")
//nvmOPCODE(EXIT,				"exit",				T_1INT_ARG_INST,			0xff,		OP_TYPE_STMT|OP_MISC|MISC_EXIT,															"exit|Miscellaneous|Exit from the current context reporting en error message|none|N/A|No elements are pushed on or popped from the stack")
nvmOPCODE(INFOCLR,			"info.clr",			T_NO_ARG_INST,				0xb2,		OP_TYPE_STMT|OP_MISC,																	"info.clr|Miscellaneous|Fills the info memory with 0s|none| (none) |Fills the info memory with 0s")
nvmOPCODE(TSTAMP_S,			"tstamp_s",			T_NO_ARG_INST,				0x58,		OP_TYPE_NTERM|OP_STACK|STK_TSTAMP|NO_OPS|ONE_DEF,										"tstamp_s|Miscellaneous|This instruction puts on the stack the current timestamp in the Unix format (nanoseconds since the january 1st 1970). A value is returned by this instruction, the current time in seconds|The stack is full (No more elements can be pushed on the stack)|(none) value1|value1 contains the number of seconds")
nvmOPCODE(TSTAMP_US,		"tstamp_us",		T_NO_ARG_INST,				0x59,		OP_TYPE_NTERM|OP_STACK|STK_TSTAMP|NO_OPS|ONE_DEF,										"tstamp|Miscellaneous|This instruction puts on the stack the current timestamp in the Unix format (nanoseconds since the january 1st 1970). A value is returned by this instruction, the number of nanoseconds of the current time|The stack is full (No more elements can be pushed on the stack)|(none) value1|value1 contains the number of nanoseconds of the current timestamp")

nvmOPCODE(IESWAP,			"ieswap",			T_NO_ARG_INST,				0x5d,		OP_TYPE_NTERM|OP_STACK|STK_IESWAP|TWO_OPS|ONE_DEF,										"ieswap|Miscellaneous|Exchange the mode between little endian and big endian for the element on the top of the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value -> result|value:abcd, where a,b,c and d are 8 bits long -> result: badc")
//nvmOPCODE(SLEEP,			"sleep",			T_NO_ARG_INST,				0xd6,		OP_TYPE_NTERM|OP_STACK|STK_SLEEP|ONE_OP|NO_DEF,											"sleep|Miscellaneous|Sleep for a time specified on the stack||value -> (none)|Sleep for a time specified on the stack")
nvmOPCODE(PBL,				"pbl",				T_NO_ARG_INST,				0xe0,		OP_TYPE_NTERM|OP_STACK|STK_PBL|NO_OPS|ONE_DEF,											"pbl|Miscellaneous|Returns the packet buffer length on the stack|The stack is full (No more elements can be pushed on the stack)|(none) -> value|Returns the packet buffer length on the stack")


// MACROINSTRUCTIONS

//Bit manipulation macroinstructions
nvmOPCODE(FINDBITSET,		"find.bit",			T_NO_ARG_INST,				0xa0,		OP_TYPE_NTERM|OP_MACRO|MACRO_FINDBITSET,												"find|Bit manipulation|Find bit operations|The stack is empty (i.e., no elements can be popped out from the stack)|value, (mask) -> result|Return the position of the first set bit in the top value of the stack")
nvmOPCODE(MFINDBITSET,		"mfind.bit",		T_NO_ARG_INST,				0xa1,		OP_TYPE_NTERM|OP_MACRO|MACRO_MFINDBITSET,												"find|Bit manipulation||||Return the position of the first set bit in the second value on the stack, the mask is on top of the stack")
//nvmOPCODE(XFINDBITSET,		"xfind.bit",		T_1BYTE_ARG_INST,			0xa2,		OP_TYPE_NTERM|OP_MACRO|MACRO_XFINDBITSET,												"find|Bit manipulation||||Return position fof the first set bit in the last top values of the stack")
//nvmOPCODE(XMFINDBITSET,		"xmfind.bit",		T_1BYTE_ARG_INST,			0xa3,		OP_TYPE_NTERM|OP_MACRO|MACRO_XMFINDBITSET,												"find|Bit manipulation||||Return position fof the first set bit in the last top values of the stack, with mask")
nvmOPCODE(SETBIT,			"set.bit",			T_NO_ARG_INST,				0xe4,		OP_TYPE_STMT|OP_MACRO|MACRO_SETBIT,														"bit|Bit manipulation|Bit test and set operations|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 -> result|Set the bit at the position specified by the top value of the stack of the second element on the top of the stack")
nvmOPCODE(CLEARBIT,			"clear.bit",		T_NO_ARG_INST,				0xe5,		OP_TYPE_STMT|OP_MACRO|MACRO_CLEARBIT,													"bit|Bit manipulation||||Clear the bit at the position specified by the top value of the stack of the second element on the top of the stack")
nvmOPCODE(FLIPBIT,			"flip.bit",			T_NO_ARG_INST,				0xe6,		OP_TYPE_STMT|OP_MACRO|MACRO_FLIPBIT,													"bit|Bit manipulation||||Flip the bit at the position specified by the top value of the stack of the second element on the top of the stack")
nvmOPCODE(TESTBIT,			"test.bit",			T_NO_ARG_INST,				0xe7,		OP_TYPE_STMT|OP_MACRO|MACRO_TESTBIT,													"bit|Bit manipulation||||Test the bit at the position specified by the top value of the stack of the second element on the top of the stack and push its value on the stack")
nvmOPCODE(TESTNBIT,			"testn.bit",		T_NO_ARG_INST,				0xe8,		OP_TYPE_NTERM|OP_MACRO|MACRO_TESTNBIT,													"bit|Bit manipulation||||Flip the bit at the position specified by the top value of the stack of the second element n the top of the stack and push its value on the stack")
nvmOPCODE(CLZ,				"clz",				T_NO_ARG_INST,				0xaf,		OP_TYPE_NTERM|OP_MACRO|MACRO_CLZ,														"clz|Bit manipulation|Count leading zeros|The stack is empty (i.e., no elements can be popped out from the stack)|value -> result|Count the consecutive number of zeros starting from the MSB")

//Hashing
//nvmOPCODE(HASH32,			"hash.32",			T_NO_ARG_INST,				0xfa,		OP_TYPE_NTERM|OP_HASH|HASH_HASH32,														"hash|Hashing|Calculates the 32 bit hash of the the data on the stack||value -> result|Computes a 32 bit hash on a single value on top of the stack")
//nvmOPCODE(HASH,			"hash",				T_1BYTE_ARG_INST,			0xfb,		OP_TYPE_NTERM|OP_HASH|HASH_HASH,														"hash|Hashing|||value1, (...), (value n) -> result|Computes a hash on the N topmost values of the stack")





//Checksum calculation and update
//nvmOPCODE(CHKSUMADD,		"chksum.add",		T_NO_ARG_INST,				0xd1,		OP_TYPE_NTERM|OP_CHKSM|CHKSM_CHKSUMADD,													"chksum|Checksum calculation||||Update a checksum from stack adding a 16 bit value taken from stack")
//nvmOPCODE(CHKSUMSUB,		"chksum.sub",		T_NO_ARG_INST,				0xd2,		OP_TYPE_NTERM|OP_CHKSM|CHKSM_CHKSUMSUB,													"chksum|Checksum calculation||||Update a checksum from stack subtracting a 16 bit value taken from stack")
//nvmOPCODE(CHKSUMCALCPKT,	"chksum.calc",		T_NO_ARG_INST,				0xd3,		OP_TYPE_NTERM|OP_CHKSM|CHKSM_CHKSUMCALCPKT,												"chksum|Checksum calculation||||Calculate the checksum as specyfied by RFC 1071 taking values from packet buffer")
//nvmOPCODE(JUMPCHECKSUM,		"chksum.jump",		T_1_SHORT_LABEL_INST,		0xd4,		OP_TYPE_STMT|OP_CHKSM|CHKSM_JUMPCHECKSUM,												"chksum|Checksum calculation||||Calculate the checksum as specyfied by RFC 1071 and branch if the result is 0xffff")
//nvmOPCODE(CRCCALC,			"crc.calc",			T_1BYTE_ARG_INST,			0xd5,		OP_TYPE_NTERM|OP_CHKSM|CHKSM_CHKSUMADD,													"crc|Checksum calculation||||Calculate the specified CRC for the top value of the stack")
//nvmOPCODE(CRCCALCPKT,		"crc.calcpkt",		T_1BYTE_ARG_INST,			0xd0,		OP_TYPE_NTERM|OP_CHKSM|CHKSM_CHKSUMADD,													"crc|Checksum calculation||||Calculate the specified CRC for a buffer inside packet buffer")

//locals management
nvmOPCODE(LOCLD,			"locload",			T_1INT_ARG_INST,			0xd9,		OP_TYPE_TERM|OP_LOC|LOC_LOCLD|NO_OPS|ONE_DEF,											"locld|Locals management|Loads a local variable|The stack is full (no value can be pushed on the stack); the local index is invalid| (none) -> value |loads the value of a local variable on the top of the stack (argument is the local index)")
nvmOPCODE(LOCST,			"locstore",			T_1INT_ARG_INST,			0xda,		OP_TYPE_STMT|OP_LOC|LOC_LOCST|ONE_OP|ONE_DEF,											"locst|Locals management|Stores a value in a local variable|The stack is empty (i.e., no elements can be popped out from the stack); the local index is invalid| value -> (none) |Stores the value on the top of the stack in a local variable (argument is the local index)")

// Coprocessor Interaction
nvmOPCODE(COPINIT,			"copro.init",		T_COPRO_INIT_INST,			0xfd,		OP_TYPE_STMT|OP_COP|COP_COPINIT|NO_OPS|ONE_DEF,											"copro.init|Coprocessor Interaction|Call coprocessor initialisation function|No such coprocessor exists| value -> value |Call coprocessor initialisation function")
nvmOPCODE(COPIN,			"copro.in",			T_2_COPRO_IO_ARG_INST,		0xf8,		OP_TYPE_STMT|OP_COP|COP_COPIN|NO_OPS|ONE_DEF,											"copro.in|Coprocessor Interaction|Read a value from a coprocessor register|The stack is full (no value can be pushed on the stack); No such coprocessor exists; the coprocessor has no such register| (none) -> value |Read a value from a coprocessor register")
nvmOPCODE(COPOUT,			"copro.out",		T_2_COPRO_IO_ARG_INST,		0xf9,		OP_TYPE_STMT|OP_COP|COP_COPOUT|ONE_OP|NO_DEF,											"copro.out|Coprocessor Interaction|Write a value to a coprocessor register|No such coprocessor exists; the coprocessor has no such register| value -> (none) |Write a value to a coprocessor register")
nvmOPCODE(COPRUN,			"copro.invoke",		T_2_COPRO_IO_ARG_INST,		0xfc,		OP_TYPE_STMT|OP_COP|COP_COPRUN|NO_OPS|NO_DEF,											"copro.invoke|Coprocessor Interaction|Invoke execution of a coprocessor|No such coprocessor exists; exception generated from coprocessor execution| (none) |Invoke execution of a coprocessor")
nvmOPCODE(COPPKTOUT,		"copro.exbuf",		T_1_COPRO_IO_ARG_INST,		0xfe,		OP_TYPE_STMT|OP_COP|COP_COPRUN|NO_OPS|NO_DEF,											"copro.exbuf|Coprocessor Interaction|Pass the current exchange buffer to a coprocessor|No such coprocessor exists; exception generated from coprocessor execution| (none) |Pass the exchange buffer to a coprocessor")
