/*****************************************************************************/
/*                                                                           */
/* Copyright notice: please read file license.txt in the NetBee root folder. */
/*                                                                           */
/*****************************************************************************/

/**
 * WARNING: the inssel-x64.h file is autogenerated from inssel-x64.brg !!
 */

#include <stdio.h>
#include "nbnetvm.h"
#include "mirnode.h"
#include "opcodes.h"
#include "cfg.h"
#include "../../../nbee/globals/debug.h"
#include "x64-asm.h"
#include "offsets.h"
#include "application.h"
#include "x64_switch_lowering.h"

#include "int_structs.h"
#include "rt_environment.h"
#include <iostream>
#include <sstream>



#define MBMAX_OPCODES 256
#define MBTREE_TYPE jit::MIRNode
#define MBREG_TYPE jit::RegisterInstance
#define MBTREE_LEFT(t) ((t)->getKid(0))
#define MBTREE_RIGHT(t) ((t)->getKid(1))
#define MBTREE_OP(t) ((t)->getOpcode())
#define MBTREE_STATE(t) ((t)->state)
#define MBTREE_VALUE(t) ((t)->getDefReg())
#define MBALLOC_STATE   new MBState()
#define MBGET_OP_NAME(opcode) nvmOpCodeTable[opcode].CodeName

#define MBTREE_GET_CONST_VALUE(t) (((ConstNode *)t)->getValue())

#define REG_NAME(R) (R).get_model()->get_name()
#define APPLICATION Application::getApp(BB)
#define REG_SPACE 1

typedef jit::x64::x64Instruction IR;

namespace jit
{
	namespace x64 {


		typedef enum
			{
				packet,
				info,
				data,
				invalid
			} mem_type;


		class x64_base_address_man{

			public:

			typedef enum
			{
				packet,
				info,
				data,
				invalid
			} base_mem_type;

			void setBase(base_mem_type type, MBREG_TYPE& base_reg);
			MBREG_TYPE* getBase(base_mem_type type) const;

			void reset();
			base_mem_type getType(MIRNode* insn);

			x64_base_address_man();

			static MBREG_TYPE load_base(CFG<IR>& cfg, base_mem_type type);
			static MBREG_TYPE load_base(CFG<IR>& cfg, MIRNode* insn);



			static std::string get_mem_string(base_mem_type type);

			private:
			MBREG_TYPE* bases[2];

		};

		class x64_dim_man{

			public:

			typedef enum
			{
				packet,
				info,
				data,
				invalid
			} dim_mem_type;


			void setDim(dim_mem_type type, MBREG_TYPE& dim_reg);
			MBREG_TYPE* getDim(dim_mem_type type) const;
			void reset();
			dim_mem_type getType(MIRNode* insn);

			x64_dim_man();


			static MBREG_TYPE load_dim(CFG<IR>& cfg, dim_mem_type type);
			static MBREG_TYPE load_dim(CFG<IR>& cfg, MIRNode* insn);

			static std::string get_mem_string(dim_mem_type type);

			private:
			MBREG_TYPE* dim[2];
		};

		x64ConditionCodes get_cond_code(JumpMIRNode* insn, bool leftConst = false);
		x64OpCodesEnum get_alu_opcode(MIRNode* insn);

		void load_coprocessors_regs(BasicBlock<IR>& BB, CopMIRNode* insn);
		void store_coprocessors_regs(BasicBlock<IR>& BB, CopMIRNode* insn);

		void emit_stop_prof_counter(BasicBlock<IR>& BB, uint32_t stack_offset = 0);
		void emit_start_prof_counter(BasicBlock<IR>& BB, uint32_t stack_offset = 0);

		x64OpndSz get_size_op(MIRNode* insn);


		extern jit::nvmStructOffsets<uint64_t> x64_offsets;
		extern x64_base_address_man base_manager;
		extern x64_dim_man dim_manager;
	}
}


#include "x64_counters.h"

using namespace jit;
using namespace x64;


#ifdef _EXP_COPROCESSOR_MODEL
static MBREG_TYPE newReg;
#endif

//#define _DEBUG_X64_INSSEL

%%

%term CNST RET SNDPKT IINC_1 IDEC_1 LDREG STREG PHI SWITCH
%term CMP
%term AND OR
%term SUBUOV ADDUOV SUB ADD IMUL MOD USHR SHR  SHL NEG NOT
%term JCMPEQ JCMPNEQ JCMPLE JCMPL JCMPG JCMPGE JUMPW JNE JEQ JUMP
%term COPRUN COPPKTOUT COPINIT
%term  PBL LDPORT
%term  PCHECK ICHECK DCHECK

;packet load terminals
%term PBLDS PBLDU PSLDS PSLDU PILD
;packet store terminals
%term PBSTR PSSTR PISTR
;info load terminals
%term ISBLD ISSBLD ISSLD ISSSLD ISSILD
;info store terminals
%term IBSTR ISSTR IISTR
;data load terminals
%term DBLDS DBLDU DSLDS DSLDU DILD
;data store terminals
%term DBSTR DSSTR DISTR

%term INFOCLR

%term JFLDEQ JFLDNEQ JFLDGT JFLDLT NOP

%term TSTAMP_S TSTAMP_US

%start stmt

stmt: PCHECK(con, con)
{
		counter_check_profiling( BB, x64_dim_man::packet);

		x64Instruction* bound_check_insn;
		x64ConditionCodes cond_code_check = L;

		std::string comment = std::string("CHECK PKT I-I");
		MBREG_TYPE dim_mem(x64_dim_man::load_dim(cfg, x64_dim_man::packet));

		uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
		uint32_t num_byte = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

		bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, displ + num_byte, dim_mem, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

}

stmt: PCHECK(reg, con)
{
		counter_check_profiling( BB, x64_dim_man::packet);

		x64Instruction* bound_check_insn;
		x64ConditionCodes cond_code_check = G;

		std::string comment = std::string("CHECK PKT R-I");
		MBREG_TYPE dim_mem(x64_dim_man::load_dim(cfg, x64_dim_man::packet));

		MBREG_TYPE displ = MBTREE_VALUE(MBTREE_LEFT(tree));
		uint32_t num_byte = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

		MBREG_TYPE displ_tmp(X64_NEW_VIRT_REG);

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ,  displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn, comment.c_str());

		bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, num_byte , displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_CMP, dim_mem, displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());


}

stmt: PCHECK(con, reg)
{
		counter_check_profiling( BB, x64_dim_man::packet);

		x64Instruction* bound_check_insn;
		x64ConditionCodes cond_code_check = G;

		std::string comment = std::string("CHECK PKT I-R");
		MBREG_TYPE dim_mem(x64_dim_man::load_dim(cfg, x64_dim_man::packet));

		uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
		MBREG_TYPE num_byte = MBTREE_VALUE(MBTREE_RIGHT(tree));

		bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, displ, num_byte , x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_CMP, dim_mem, num_byte, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());


}

stmt: PCHECK(reg, reg)
{
		counter_check_profiling( BB, x64_dim_man::packet);

		x64Instruction* bound_check_insn;
		x64ConditionCodes cond_code_check = G;

		std::string comment = std::string("CHECK PKT R-R");
		MBREG_TYPE dim_mem(x64_dim_man::load_dim(cfg, x64_dim_man::packet));

		MBREG_TYPE displ = MBTREE_VALUE(MBTREE_LEFT(tree));
		MBREG_TYPE num_byte = MBTREE_VALUE(MBTREE_RIGHT(tree));

		MBREG_TYPE displ_tmp(X64_NEW_VIRT_REG);

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ,  displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn, comment.c_str());

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, num_byte , displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_CMP, dim_mem, displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

}


stmt: ICHECK(con, con)
{
	counter_check_profiling( BB, x64_dim_man::info);

		x64Instruction* bound_check_insn;
		//x64ConditionCodes cond_code_check = L;
		std::string comment = std::string("CHECK INFO I-I");

		uint32_t dim_mem = (uint32_t)jit::Application::getApp(BB.getId()).getMemDescriptor(jit::Application::info).Size;

		uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
		uint32_t num_byte = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

		if( displ + num_byte > dim_mem )
		{
		//bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		//x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());
			bound_check_insn = x64_Asm_JMP_Label(BB.getCode(), cfg.getExitBB()->getId());

			x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		}

}

stmt: ICHECK(reg, con)
{
	counter_check_profiling( BB, x64_dim_man::info);

			x64Instruction* bound_check_insn;
			x64ConditionCodes cond_code_check = G;
			std::string comment = std::string("CHECK INFO R-I");
			uint32_t dim_mem = (uint32_t)jit::Application::getApp(BB.getId()).getMemDescriptor(jit::Application::info).Size;

			MBREG_TYPE displ = MBTREE_VALUE(MBTREE_LEFT(tree));
			uint32_t num_byte = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

			MBREG_TYPE displ_tmp(X64_NEW_VIRT_REG);

			bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ,  displ_tmp, x64_DWORD);
			x64_Asm_Append_Comment(bound_check_insn, comment.c_str());

			//bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, num_byte , displ_tmp, x64_DWORD);
			//x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

			bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, dim_mem - num_byte , displ_tmp, x64_DWORD);
			x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

			bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
			x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());
}

stmt: ICHECK(con, reg)
{
		counter_check_profiling( BB, x64_dim_man::info);

		x64Instruction* bound_check_insn;
		x64ConditionCodes cond_code_check = G;
		std::string comment = std::string("CHECK INFO I-R");
		uint32_t dim_mem = (uint32_t)jit::Application::getApp(BB.getId()).getMemDescriptor(jit::Application::info).Size;

		uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
		MBREG_TYPE num_byte = MBTREE_VALUE(MBTREE_RIGHT(tree));

		//bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, displ, num_byte , x64_DWORD);
		//x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, dim_mem - displ, num_byte, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());


}

stmt: ICHECK(reg, reg)
{
		counter_check_profiling( BB, x64_dim_man::info);

		x64Instruction* bound_check_insn;
		x64ConditionCodes cond_code_check = G;
		std::string comment = std::string("CHECK INFO R-R");
		uint32_t dim_mem = (uint32_t)jit::Application::getApp(BB.getId()).getMemDescriptor(jit::Application::info).Size;

		MBREG_TYPE displ = MBTREE_VALUE(MBTREE_LEFT(tree));
		MBREG_TYPE num_byte = MBTREE_VALUE(MBTREE_RIGHT(tree));

		MBREG_TYPE displ_tmp(X64_NEW_VIRT_REG);

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ,  displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn, comment.c_str());

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, num_byte , displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, dim_mem, displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

}



stmt: DCHECK(con, con)
{
		counter_check_profiling( BB, x64_dim_man::data);


		x64Instruction* bound_check_insn;
		//x64ConditionCodes cond_code_check = L;
		std::string comment = std::string("CHECK DATA I-I");
		uint32_t dim_mem = (uint32_t)jit::Application::getApp(BB.getId()).getMemDescriptor(jit::Application::data).Size;

		uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
		uint32_t num_byte = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

		if( displ + num_byte > dim_mem )
		{
		//bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		//x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());
		bound_check_insn = x64_Asm_JMP_Label(BB.getCode(), cfg.getExitBB()->getId());
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());
		}

}

stmt: DCHECK(reg, con)
{
		counter_check_profiling( BB, x64_dim_man::data);

		x64Instruction* bound_check_insn;
		x64ConditionCodes cond_code_check = G;
		std::string comment = std::string("CHECK DATA R-I");
		uint32_t dim_mem = (uint32_t)jit::Application::getApp(BB.getId()).getMemDescriptor(jit::Application::data).Size;

		MBREG_TYPE displ = MBTREE_VALUE(MBTREE_LEFT(tree));
		uint32_t num_byte = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

		MBREG_TYPE displ_tmp(X64_NEW_VIRT_REG);

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ,  displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn, comment.c_str());

		//bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, num_byte , displ_tmp, x64_DWORD);
		//x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, dim_mem - num_byte, displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());



}

stmt: DCHECK(con, reg)
{
		counter_check_profiling( BB, x64_dim_man::data);

		x64Instruction* bound_check_insn;
		x64ConditionCodes cond_code_check = G;
		std::string comment = std::string("CHECK DATA I-R");
		uint32_t dim_mem = (uint32_t)jit::Application::getApp(BB.getId()).getMemDescriptor(jit::Application::data).Size;

		uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
		MBREG_TYPE num_byte = MBTREE_VALUE(MBTREE_RIGHT(tree));

		//bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, displ, num_byte , x64_DWORD);
		//x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, dim_mem - displ, num_byte, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

}

stmt: DCHECK(reg, reg)
{
		counter_check_profiling( BB, x64_dim_man::data);

		x64Instruction* bound_check_insn;
		x64ConditionCodes cond_code_check = G;
		std::string comment = std::string("CHECK DATA R-R");
		uint32_t dim_mem = (uint32_t)jit::Application::getApp(BB.getId()).getMemDescriptor(jit::Application::data).Size;

		MBREG_TYPE displ = MBTREE_VALUE(MBTREE_LEFT(tree));
		MBREG_TYPE num_byte = MBTREE_VALUE(MBTREE_RIGHT(tree));

		MBREG_TYPE displ_tmp(X64_NEW_VIRT_REG);

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ,  displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn, comment.c_str());

		bound_check_insn = x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, num_byte , displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, dim_mem, displ_tmp, x64_DWORD);
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

		bound_check_insn = x64_Asm_J_Label(BB.getCode(), cond_code_check, cfg.getExitBB()->getId());
		x64_Asm_Append_Comment(bound_check_insn,  comment.c_str());

}


stmt: INFOCLR
{
MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, x64_base_address_man::info));
uint32_t dim_mem = (uint32_t)jit::Application::getApp(BB.getId()).getMemDescriptor(jit::Application::info).Size;



	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, 0, X64_MACH_REG(AL), x64_BYTE);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, dim_mem,  X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op(BB.getCode(), X64_STOSB);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);

}

reg: LDPORT
{
	#ifdef _DEBUG_X64_INSSEL
		std::cout << "\tldport\n";
	#endif
}

con: CNST
{
	#ifdef _DEBUG_X64_INSSEL
		std::cout << "\tcon" << MBTREE_VALUE(tree) << "\t: CNST\n";
	#endif
}

stmt: RET
{
	#ifdef _DEBUG_X64_INSSEL
		std::cout << "\tRET\n";
	#endif

	#ifdef JIT_RTE_PROFILE_COUNTERS
	emit_stop_prof_counter(BB);
	#endif

	x64_Asm_Comment(BB.getCode(), "Dropping packet!!!");
	x64_Asm_Comment(BB.getCode(), "Now go to function epilogue");
	//x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, nvmFAILURE , X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_JMP_Label(BB.getCode(), cfg.getExitBB()->getId());
}

reg: COPINIT
{
	CopMIRNode* insn = dynamic_cast<CopMIRNode*>(tree);
	assert(insn != NULL);

	nvmCoprocessorState* copro = APPLICATION.getCoprocessor(insn->getcoproId());
	uint64_t init_func_addr = (uint64_t)copro->init;

	nvmMemDescriptor mem = APPLICATION.getMemDescriptor(Application::inited);
	uint64_t base_addr = (uint64_t)mem.Base;

	MBREG_TYPE dst = MBTREE_VALUE(insn);

#ifdef _DEBUG_X64_INSSEL
	printf("salvo i registri\n");
	printf("\tPUSH %d\t;push offset\n", base_addr + insn->getcoproInitOffset());
	printf("\tPUSH 0x%x\t;coprocessor state address\n", (uint64_t)copro);
	printf("\tCALL 0x%x\t;invoke function address\n", init_func_addr);
	printf("\tADD ESP, 8\n");
	printf("\tMOV R%d, EAX\t;save return value\n", REG_NAME(dst));
	printf("recupero i registri\n");
#endif

	x64_Asm_Op(BB.getCode(), X64_SAVEREGS);
  NETVM_ASSERT(1==0, "COPINIT not impl");
	x64_Asm_Op_Imm(BB.getCode(), X64_PUSH, base_addr + insn->getcoproInitOffset());
	x64_Asm_Op_Imm(BB.getCode(), X64_PUSH, (uint64_t)copro);
	x64_Asm_Op_Imm(BB.getCode(), X64_CALL, init_func_addr);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, 8, X64_MACH_REG(ESP), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(EAX), dst, x64_DWORD);

	x64_Asm_Op(BB.getCode(), X64_LOADREGS);
}

stmt: COPRUN
{
	CopMIRNode* insn = dynamic_cast<CopMIRNode*>(tree);
	assert(insn != NULL);

	nvmCoprocessorState* copro = APPLICATION.getCoprocessor(insn->getcoproId());
	uint64_t run_func_addr = (uint64_t)copro->invoke;

	//load_coprocessors_regs(BB, insn);

	x64_Asm_Op(BB.getCode(), X64_SAVEREGS);

#ifdef JIT_RTE_PROFILE_COUNTERS
	emit_stop_prof_counter(BB, 12);
#endif

#ifdef _EXP_COPROCESSOR_MODEL

	NETVM_ASSERT(1==0, "_EXP_COPROCESSOR_MODEL not impl");
	if (strcmp(copro->name, "lookupnew") == 0)
	{

		if (copro->OpFunctions[insn->getcoproOp()] == NULL)
		{
			x64_Asm_Op_Imm(BB.getCode(), X64_PUSH, insn->getcoproOp());
			x64_Asm_Op_Imm(BB.getCode(), X64_PUSH, (uint64_t)copro);
			x64_Asm_Op_Imm(BB.getCode(), X64_CALL, run_func_addr);
			x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, 8, X64_MACH_REG(ESP), x64_DWORD);
		}
		else
		{
			x64_Asm_Op_Imm(BB.getCode(), X64_PUSH, (uint64_t)copro);
			x64_Asm_Op_Imm(BB.getCode(), X64_CALL, (uint64_t)copro->OpFunctions[insn->getcoproOp()]);
			x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, 4, X64_MACH_REG(ESP), x64_DWORD);
			if (insn->getcoproOp() == 2) //lookup
			{
				newReg = X64_NEW_VIRT_REG;
				x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(EAX), newReg, x64_DWORD);
			}
		}
	}
	else
	{
#endif

	MBREG_TYPE reg(X64_NEW_VIRT_REG);

	//x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD); //done by X64_LOADREGS
	//x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD); //done by X64_LOADREGS
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, insn->getcoproOp(), X64_MACH_REG(COPRO_OPERATION_REGISTER), x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, (uint64_t)copro, X64_MACH_REG(COPRO_STATE_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, run_func_addr, reg, x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_CALL, reg, x64_QWORD);
	//x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD); //done by X64_LOADREGS
	//x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD); //done by X64_LOADREGS

#ifdef _EXP_COPROCESSOR_MODEL
	}
#endif

#ifdef JIT_RTE_PROFILE_COUNTERS
	emit_start_prof_counter(BB, 12);
#endif
	x64_Asm_Op(BB.getCode(), X64_LOADREGS);

	//store_coprocessors_regs(BB, insn);
}

stmt: COPPKTOUT
{
	CopMIRNode* insn = dynamic_cast<CopMIRNode*>(tree);
	assert(insn != NULL);

	nvmCoprocessorState* copro = APPLICATION.getCoprocessor(insn->getcoproId());
	uint64_t store_addr = (uint64_t)&copro->xbuf;

	MBREG_TYPE reg(X64_NEW_VIRT_REG);
	MBREG_TYPE regStore(X64_NEW_VIRT_REG);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV %d, 8[RBP]\t;COPPKTOUT\n", REG_NAME(reg));
	printf("\tMOV %d, [%d]\t;COPPKTOUT\n", REG_NAME(reg), REG_NAME(reg));
	printf("\tMOV [0x%x], %d\t;COPPKTOUT\n", store_addr, REG_NAME(reg));
#endif

	//x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(RBP), 8, reg, x64_QWORD);
	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), 0, reg, x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, store_addr, regStore, x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, reg, regStore, 0, x64_QWORD);
}

stmt: SNDPKT
{
#ifndef CODE_PROFILING
	uint32_t port = ((SndPktNode *)tree)->getPort_number();
	nvmHandlerState* HandlerState = APPLICATION.getCurrentPEHandler()->HandlerState;

	nvmHandlerFunction *f = HandlerState->PEState->ConnTable[port].CtdHandlerFunct;
	nvmHandlerState *h    = HandlerState->PEState->ConnTable[port].CtdHandler;
	uint32_t ctdPort     = HandlerState->Handler->OwnerPE->PortTable[port].CtdPort;

#ifdef JIT_RTE_PROFILE_COUNTERS
   emit_stop_prof_counter(BB);
#endif

	x64Instruction* insn;

	x64_Asm_Comment(BB.getCode(), "Pass packet to next handler");
	
	x64_Asm_Op(BB.getCode(), X64_SAVEREGS);
	//x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	//x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	//x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(HANDLER_STATE_REGISTER), x64_QWORD);
	
	insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, (uint64_t)h, X64_MACH_REG(HANDLER_STATE_REGISTER), x64_QWORD); x64_Asm_Append_Comment(insn, "handler pointer on HANDLER_STATE_REGISTER");
	insn = x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, ctdPort, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD); x64_Asm_Append_Comment(insn, "next port on INPUT_PORT_REGISTER");
	//insn = x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), 8, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER) , x64_QWORD); x64_Asm_Append_Comment(insn, "exbuf pointer on EXCHANGE_BUFFER_REGISTER");


	MBREG_TYPE reg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, (uint64_t)f, reg, x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_CALL, reg, x64_QWORD);

	//x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(HANDLER_STATE_REGISTER), x64_QWORD);
	//x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	//x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	
	x64_Asm_Op(BB.getCode(), X64_LOADREGS);
#endif
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; JFLDxx operations
;

stmt: JFLDNEQ(con, NOP(con, con)),
stmt: JFLDLT(con, NOP(con, con)),
stmt: JFLDGT(con, NOP(con, con)),
stmt: JFLDEQ(con, NOP(con, con))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);
	uint32_t target = jump->getTrueTarget();

	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet));
	uint32_t len = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));

	MIRNode* nop = MBTREE_RIGHT(tree);
	uint32_t off1 = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(nop));
	uint32_t off2 = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(nop));

	x64ConditionCodes code = get_cond_code(jump);

	//bounds_check_IMM_IMM(cfg,  BB , off1 , len, x64_dim_man::packet);
	//bounds_check_IMM_IMM(cfg,  BB ,off2 , len, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);
	counter_access_mem_profiling( BB, x64_dim_man::packet);

	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(ECX), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, off1, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, off2, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, len,  X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op(BB.getCode(), X64_CMPSB);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(RCX), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_J_Label(BB.getCode(), code, target);
}

stmt: JFLDNEQ(reg, NOP(con, con)),
stmt: JFLDLT(reg, NOP(con, con)),
stmt: JFLDGT(reg, NOP(con, con)),
stmt: JFLDEQ(reg, NOP(con, con))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);
	uint32_t target = jump->getTrueTarget();

	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet));
	MBREG_TYPE len = MBTREE_VALUE(MBTREE_LEFT(tree));

	MIRNode* nop = MBTREE_RIGHT(tree);
	uint32_t off1 = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(nop));
	uint32_t off2 = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(nop));

	//bounds_check_IMM_REG(cfg, BB, off1 , len, x64_dim_man::packet);
	//bounds_check_IMM_REG(cfg, BB, off2 , len, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);
	counter_access_mem_profiling( BB, x64_dim_man::packet);
	x64ConditionCodes code = get_cond_code(jump);

	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(ECX), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, off1, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, off2, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, len,  X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op(BB.getCode(), X64_CMPSB);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(RCX), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_J_Label(BB.getCode(), code, target);
}

stmt: JFLDNEQ(con, NOP(reg, con)),
stmt: JFLDLT (con, NOP(reg, con)),
stmt: JFLDGT (con, NOP(reg, con)),
stmt: JFLDEQ (con, NOP(reg, con))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);
	uint32_t target = jump->getTrueTarget();

	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet));
	uint32_t len = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));

	MIRNode* nop = MBTREE_RIGHT(tree);
	MBREG_TYPE off1 = MBTREE_VALUE(MBTREE_LEFT(nop));
	uint32_t off2 = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(nop));

	//bounds_check_REG_IMM(cfg, BB, off1 , len, x64_dim_man::packet);
	//bounds_check_IMM_IMM(cfg, BB ,off2 , len, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);
	counter_access_mem_profiling( BB, x64_dim_man::packet);

	x64ConditionCodes code = get_cond_code(jump);

	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(ECX), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, off1, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, off2, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, len,  X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op(BB.getCode(), X64_CMPSB);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(RCX), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_J_Label(BB.getCode(), code, target);
}

stmt: JFLDNEQ(con, NOP(con, reg)),
stmt: JFLDLT (con, NOP(con, reg)),
stmt: JFLDGT (con, NOP(con, reg)),
stmt: JFLDEQ (con, NOP(con, reg))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);
	uint32_t target = jump->getTrueTarget();

	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet));
	uint32_t len = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));

	MIRNode* nop = MBTREE_RIGHT(tree);
	uint32_t off1 = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(nop));
	MBREG_TYPE off2 = MBTREE_VALUE(MBTREE_RIGHT(nop));

	//bounds_check_IMM_IMM(cfg, BB, off1 , len, x64_dim_man::packet);
	//bounds_check_REG_IMM(cfg, BB, off2 , len, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);
	counter_access_mem_profiling( BB, x64_dim_man::packet);

	x64ConditionCodes code = get_cond_code(jump);

	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(ECX), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, off1, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, off2, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, len,  X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op(BB.getCode(), X64_CMPSB);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(RCX), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_J_Label(BB.getCode(), code, target);
}

stmt: JFLDNEQ(con, NOP(reg, reg)),
stmt: JFLDLT (con, NOP(reg, reg)),
stmt: JFLDGT (con, NOP(reg, reg)),
stmt: JFLDEQ (con, NOP(reg, reg))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);
	uint32_t target = jump->getTrueTarget();

	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet));
	uint32_t len = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));

	MIRNode* nop = MBTREE_RIGHT(tree);
	MBREG_TYPE off1 = MBTREE_VALUE(MBTREE_LEFT(nop));
	MBREG_TYPE off2 = MBTREE_VALUE(MBTREE_RIGHT(nop));

	//bounds_check_REG_IMM(cfg, BB , off1 , len, x64_dim_man::packet);
	//bounds_check_REG_IMM(cfg, BB, off2 , len, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);
	counter_access_mem_profiling( BB, x64_dim_man::packet);

	x64ConditionCodes code = get_cond_code(jump);

	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(ECX), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, off1, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, off2, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, len,  X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op(BB.getCode(), X64_CMPSB);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(RCX), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_J_Label(BB.getCode(), code, target);
}

stmt: JFLDNEQ(reg, NOP(con, reg)),
stmt: JFLDLT (reg, NOP(con, reg)),
stmt: JFLDGT (reg, NOP(con, reg)),
stmt: JFLDEQ (reg, NOP(con, reg))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);
	uint32_t target = jump->getTrueTarget();

	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet));
	MBREG_TYPE len = MBTREE_VALUE(MBTREE_LEFT(tree));

	MIRNode* nop = MBTREE_RIGHT(tree);
	uint32_t off1 = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(nop));
	MBREG_TYPE off2 = MBTREE_VALUE(MBTREE_RIGHT(nop));

	//bounds_check_IMM_REG(cfg, BB, off1 , len, x64_dim_man::packet);
	//bounds_check_REG_REG(cfg, BB, off2 , len, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);
	counter_access_mem_profiling( BB, x64_dim_man::packet);

	x64ConditionCodes code = get_cond_code(jump);

	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(ECX), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, off1, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, off2, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, len,  X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op(BB.getCode(), X64_CMPSB);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(RCX), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_J_Label(BB.getCode(), code, target);
}

stmt: JFLDNEQ(reg, NOP(reg, con)),
stmt: JFLDLT (reg, NOP(reg, con)),
stmt: JFLDGT (reg, NOP(reg, con)),
stmt: JFLDEQ (reg, NOP(reg, con))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);
	uint32_t target = jump->getTrueTarget();

	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet));
	MBREG_TYPE len = MBTREE_VALUE(MBTREE_LEFT(tree));

	MIRNode* nop = MBTREE_RIGHT(tree);
	MBREG_TYPE off1 = MBTREE_VALUE(MBTREE_LEFT(nop));
	uint32_t off2 = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(nop));

	//bounds_check_REG_REG(cfg, BB, off1 , len, x64_dim_man::packet);
	//bounds_check_IMM_REG(cfg, BB, off2 , len, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);
	counter_access_mem_profiling( BB, x64_dim_man::packet);

	x64ConditionCodes code = get_cond_code(jump);

	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(ECX), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, off1, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, off2, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, len,  X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op(BB.getCode(), X64_CMPSB);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(RCX), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_J_Label(BB.getCode(), code, target);
}

stmt: JFLDNEQ(reg, NOP(reg, reg)),
stmt: JFLDLT (reg, NOP(reg, reg)),
stmt: JFLDGT (reg, NOP(reg, reg)),
stmt: JFLDEQ (reg, NOP(reg, reg))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);
	uint32_t target = jump->getTrueTarget();

	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet));
	MBREG_TYPE len = MBTREE_VALUE(MBTREE_LEFT(tree));

	MIRNode* nop = MBTREE_RIGHT(tree);
	MBREG_TYPE off1 = MBTREE_VALUE(MBTREE_LEFT(nop));
	MBREG_TYPE off2 = MBTREE_VALUE(MBTREE_RIGHT(nop));

	//bounds_check_REG_REG(cfg, BB, off1 , len, x64_dim_man::packet);
	//bounds_check_REG_REG(cfg, BB, off2 , len, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);
	counter_access_mem_profiling( BB, x64_dim_man::packet);

	x64ConditionCodes code = get_cond_code(jump);

	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(ECX), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, off1, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, base_reg, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, off2, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, len,  X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op(BB.getCode(), X64_CMPSB);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(RCX), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_POP, X64_MACH_REG(INPUT_PORT_REGISTER), x64_QWORD);
	x64_Asm_J_Label(BB.getCode(), code, target);
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


stmt: JEQ(CMP(reg, reg)),
stmt: JNE(CMP(reg, reg))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);

	uint32_t target = jump->getTrueTarget();

	MBTREE_TYPE* cmp_tree = MBTREE_LEFT(jump);
	MBREG_TYPE srcReg1 = MBTREE_VALUE(MBTREE_LEFT(cmp_tree));
	MBREG_TYPE srcReg2 = MBTREE_VALUE(MBTREE_RIGHT(cmp_tree));

	x64ConditionCodes cond_code = get_cond_code(jump);

#ifdef _DEBUG_X64_INSSEL
	printf("\tCMP R%d, R%d\t;CMP(reg, reg)\n", REG_NAME(srcReg1), REG_NAME(srcReg2));
	printf("\tJ%s L%d\t;J%s(reg)\n", x64CC[cond_code], target, x64CC[cond_code]);
#endif

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_CMP, srcReg2, srcReg1, x64_DWORD);
	x64_Asm_J_Label(BB.getCode(), cond_code, target);

}

stmt: JEQ(CMP(reg, con)),
stmt: JNE(CMP(reg, con))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);

	uint32_t target = jump->getTrueTarget();

	MBTREE_TYPE* cmp_tree = MBTREE_LEFT(jump);
	MBREG_TYPE reg = MBTREE_VALUE(MBTREE_LEFT(cmp_tree));
	uint32_t imm = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(cmp_tree));

	x64ConditionCodes cond_code = get_cond_code(jump);

#ifdef _DEBUG_X64_INSSEL
	printf("\tCMP R%d, %d\t;CMP(reg, reg)\n", REG_NAME(reg), imm);
	printf("\tJ%s L%d\t;J%s(reg)\n", x64CC[cond_code], target, x64CC[cond_code]);
#endif

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, imm, reg, x64_DWORD);
	x64_Asm_J_Label(BB.getCode(), cond_code, target);
}

stmt: JEQ(CMP(con, reg)),
stmt: JNE(CMP(con, reg))
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);

	uint32_t target = jump->getTrueTarget();

	MBTREE_TYPE* cmp_tree = MBTREE_LEFT(jump);
	MBREG_TYPE reg = MBTREE_VALUE(MBTREE_RIGHT(cmp_tree));
	uint32_t imm = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(cmp_tree));

	x64ConditionCodes cond_code = get_cond_code(jump);

#ifdef _DEBUG_X64_INSSEL
	printf("\tCMP R%d, %d\t;CMP(reg, reg)\n", REG_NAME(reg), imm);
	printf("\tJ%s L%d\t;J%s(reg)\n", x64CC[cond_code], target, x64CC[cond_code]);
#endif

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, imm, reg, x64_DWORD);
	x64_Asm_J_Label(BB.getCode(), cond_code, target);
}

stmt: JEQ(reg),
stmt: JNE(reg)
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);

	uint32_t target = jump->getTrueTarget();

	MBTREE_TYPE* cmp_tree = MBTREE_LEFT(jump);
	MBREG_TYPE reg = MBTREE_VALUE(cmp_tree);
	uint32_t imm = 0;

	x64ConditionCodes cond_code = get_cond_code(jump);

#ifdef _DEBUG_X64_INSSEL
	printf("\tCMP R%d, %d\t;CMP(reg, reg)\n", REG_NAME(reg), imm);
	printf("\tJ%s L%d\t;J%s(reg)\n", x64CC[cond_code], target, x64CC[cond_code]);
#endif

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, imm, reg, x64_DWORD);
	x64_Asm_J_Label(BB.getCode(), cond_code, target);
}

stmt: JCMPGE (mem, con),
stmt: JCMPG  (mem, con),
stmt: JCMPL  (mem, con),
stmt: JCMPLE (mem, con),
stmt: JCMPNEQ(mem, con),
stmt: JCMPEQ (mem, con)
{
// jcmp ( stack[i-2] , stack[i -1] )  CMP stack[i -2] ,stack[i -1] mem-con

	JumpMIRNode* insn = dynamic_cast<JumpMIRNode*>(tree);
	assert(insn != NULL);

	//jump data
	uint32_t jt = insn->getTrueTarget();
	x64ConditionCodes cond_code = get_cond_code(insn);


	MIRNode* load = MBTREE_LEFT(tree);

	x64OpndSz size_op = get_size_op(load);

	//memory operation data
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, load));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(load));

	if(size_op == x64_BYTE){
		uint8_t con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
		x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_CMP, con, base_reg, displ,  x64_BYTE);
	} else if(size_op == x64_WORD){
		uint16_t con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
		x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_CMP, con, base_reg, displ, x64_WORD);
	} else {
		uint32_t con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
		x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_CMP, con, base_reg, displ, x64_DWORD);
	}

	x64_Asm_J_Label(BB.getCode(), cond_code, jt);


}


stmt: JCMPGE (memi, con),
stmt: JCMPG  (memi, con),
stmt: JCMPL  (memi, con),
stmt: JCMPLE (memi, con),
stmt: JCMPNEQ(memi, con),
stmt: JCMPEQ (memi, con)
{
// jcmp ( stack[i-2] , stack[i -1] )  CMP stack[i -2] ,stack[i -1] memi-con

	JumpMIRNode* insn = dynamic_cast<JumpMIRNode*>(tree);
	assert(insn != NULL);

	//jump data
	uint32_t jt = insn->getTrueTarget();

	x64ConditionCodes cond_code = get_cond_code(insn);

	MIRNode* load = MBTREE_LEFT(tree);

	x64OpndSz size_op = get_size_op(load);

	//memory operation data
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, load));
	MBREG_TYPE off_reg = MBTREE_VALUE(MBTREE_LEFT(load));

	if(size_op == x64_BYTE){
		uint8_t con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
		x64_Asm_Op_Imm_To_Mem_Index(BB.getCode(), X64_CMP, con, base_reg, /*X64_MACH_REG(ESI)*/ off_reg, x64_BYTE);
	} else if(size_op == x64_WORD){
		uint16_t con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
		x64_Asm_Op_Imm_To_Mem_Index(BB.getCode(), X64_CMP, con, base_reg, /*X64_MACH_REG(ESI)*/ off_reg, x64_WORD);
	} else {
		uint32_t con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
		x64_Asm_Op_Imm_To_Mem_Index(BB.getCode(), X64_CMP, con, base_reg, /*X64_MACH_REG(ESI)*/ off_reg, x64_DWORD);
	}

//	con = nvm_htonl(con);

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, off_reg, X64_MACH_REG(ESI), x64_DWORD);

	x64_Asm_J_Label(BB.getCode(), cond_code, jt);


}



%ifdef SWAP_CONST


stmt: JCMPNEQ (smem , con),
stmt: JCMPEQ  (smem , con)
{
	JumpMIRNode* insn = dynamic_cast<JumpMIRNode*>(tree);
	assert(insn != NULL);

	//jump data
	uint32_t jt = insn->getTrueTarget();
	x64ConditionCodes cond_code = get_cond_code(insn);

	MIRNode* load = MBTREE_LEFT(tree);

	x64OpndSz size_op = get_size_op(load);


	//memory operation data
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, load));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(load));


	if(size_op == x64_WORD){
		uint16_t con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
		con = nvm_htons(con);
		x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_CMP, con, base_reg, displ, x64_WORD);
	} else if(size_op == x64_DWORD){
		uint32_t con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
		con = nvm_htonl(con);
		x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_CMP, con, base_reg, displ, x64_DWORD);
	}


	x64_Asm_J_Label(BB.getCode(), cond_code, jt);
}

stmt: JCMPNEQ(smemi, con),
stmt: JCMPEQ (smemi, con)
{
	JumpMIRNode* insn = dynamic_cast<JumpMIRNode*>(tree);
	assert(insn != NULL);

	//jump data
	uint32_t jt = insn->getTrueTarget();
	x64ConditionCodes cond_code = get_cond_code(insn);

		MIRNode* load = MBTREE_LEFT(tree);

	x64OpndSz size_op = get_size_op(load);



	//memory operation data
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, load));
	MBREG_TYPE off_reg = MBTREE_VALUE(MBTREE_LEFT(load));


	if(size_op == x64_WORD){
		uint16_t con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
		con = nvm_htons(con);
		x64_Asm_Op_Imm_To_Mem_Index(BB.getCode(), X64_CMP, con, base_reg, /*X64_MACH_REG(ESI)*/ off_reg, x64_WORD);
	} else if(size_op == x64_DWORD){
		uint32_t con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
		con = nvm_htonl(con);
		x64_Asm_Op_Imm_To_Mem_Index(BB.getCode(), X64_CMP, con, base_reg, /*X64_MACH_REG(ESI)*/ off_reg, x64_DWORD);
	}


	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, off_reg, X64_MACH_REG(ESI), x64_DWORD);

	x64_Asm_J_Label(BB.getCode(), cond_code, jt);

}


%endif


stmt: JCMPNEQ(reg, reg),
stmt: JCMPGE(reg, reg),
stmt: JCMPG(reg, reg),
stmt: JCMPL(reg, reg),
stmt: JCMPLE(reg, reg),
stmt: JCMPEQ(reg, reg)
{
// jcmp ( stack[i-2] , stack[i -1] )  CMP stack[i -2] ,stack[i -1] reg-reg

	JumpMIRNode* insn = dynamic_cast<JumpMIRNode*>(tree);
	assert(insn != NULL);

	uint32_t jt = insn->getTrueTarget();
	MBREG_TYPE reg0 = MBTREE_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE reg1 = MBTREE_VALUE(MBTREE_RIGHT(tree));

	x64ConditionCodes cond_code = get_cond_code(insn);

#ifdef _DEBUG_X64_INSSEL
	printf("\tCMP R%d, R%d\t;JCMP%s(reg, reg)\n", REG_NAME(reg0), REG_NAME(reg1), x64CC[cond_code]);
	printf("\tJ%s L%d\t;JCMP%s(reg, reg)\n", x64CC[cond_code], jt, x64CC[cond_code]);
#endif

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_CMP, reg1, reg0, x64_DWORD);

	x64_Asm_J_Label(BB.getCode(), cond_code, jt);


}

stmt: JCMPGE(reg, con),
stmt: JCMPG(reg, con),
stmt: JCMPL(reg, con),
stmt: JCMPLE(reg, con),
stmt: JCMPNEQ(reg, con),
stmt: JCMPEQ(reg, con)
{
// jcmp ( stack[i-2] , stack[i -1] )  CMP stack[i -2] ,stack[i -1] reg-con

	JumpMIRNode* insn = dynamic_cast<JumpMIRNode*>(tree);
	assert(insn != NULL);

	uint32_t jt = insn->getTrueTarget();
	MBREG_TYPE reg0 = MBTREE_VALUE(MBTREE_LEFT(tree));
	uint32_t value = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

	x64ConditionCodes cond_code = get_cond_code(insn);

#ifdef _DEBUG_X64_INSSEL
	printf("\tCMP R%d, %d\t;JCMP%s(reg, con)\n", REG_NAME(reg0), value, x64CC[cond_code]);
	printf("\tJ%s L%d\t;JCMP%s(reg, reg)\n", x64CC[cond_code], jt, x64CC[cond_code]);
#endif

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, value, reg0, x64_DWORD);


	x64_Asm_J_Label(BB.getCode(), cond_code, jt);

}

stmt: JCMPNEQ(con, reg),
stmt: JCMPGE(con, reg),
stmt: JCMPG(con, reg),
stmt: JCMPL(con, reg),
stmt: JCMPLE(con, reg),
stmt: JCMPEQ(con, reg)
{
// jcmp ( stack[i-2] , stack[i -1] )  CMP stack[i -1] ,stack[i -2] con condizione salto invertita con-reg

	JumpMIRNode* insn = dynamic_cast<JumpMIRNode*>(tree);
	assert(insn != NULL);

	uint32_t jt = insn->getTrueTarget();
	uint32_t value = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE reg0 = MBTREE_VALUE(MBTREE_RIGHT(tree));

 	x64ConditionCodes cond_code = get_cond_code(insn, true); // con TRUE inverto condizione salto


#ifdef _DEBUG_X64_INSSEL
	printf("\tCMP R%d, %d\t;JCMP%s(reg, con)\n", REG_NAME(reg0), value, x64CC[cond_code]);
	printf("\tJ%s L%d\t;JCMP%s(reg, con)\n", x64CC[cond_code], jt, x64CC[cond_code]);
#endif

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, value, reg0, x64_DWORD);
	x64_Asm_J_Label(BB.getCode(), cond_code, jt);


}

stmt: JCMPNEQ(con, con),
stmt: JCMPGE(con, con),
stmt: JCMPG(con, con),
stmt: JCMPL(con, con),
stmt: JCMPLE(con, con),
stmt: JCMPEQ(con, con)
{

//jcmp ( stack[i-2] , stack[i -1] )  CMP stack[i -2] ,stack[i -1] con-con

	JumpMIRNode* insn = dynamic_cast<JumpMIRNode*>(tree);
	assert(insn != NULL);

	uint32_t jt = insn->getTrueTarget();
	uint32_t value1 = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	uint32_t value2 = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE reg0(X64_NEW_VIRT_REG);

	x64ConditionCodes cond_code = get_cond_code(insn);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV R%d, %d\t,JCMP%s(con, con)\n", REG_NAME(reg0), value1, x64CC[cond_code]);
	printf("\tCMP R%d, %d\t;JCMP%s(con, con)\n", REG_NAME(reg0), value2, x64CC[cond_code]);
	printf("\tJ%s L%d\t;JCMP%s(con, con)\n", x64CC[cond_code], jt, x64CC[cond_code]);
#endif

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, value1, reg0, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, value2, reg0, x64_DWORD);


 	x64_Asm_J_Label(BB.getCode(), cond_code, jt);

 }





;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; load from memory types
;

;;;;;;;;;;;;;;;; PACKET ;;;;;;;;;;;;;;;;;;;;;;;

pload8_mem_con: PBLDS(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);
}


reg: pload8_mem_con
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVSX, base_reg, displ, dst_reg, x64_BYTE);
}

pload8_memi_reg: PBLDS(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

}
;1 byte signed
reg: pload8_memi_reg
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ, dst_reg, x64_DWORD);
	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, base_reg, dst_reg, x64_DWORD);
	//x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVSX, dst_reg, 0, dst_reg, x64_BYTE);
	x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_MOVSX, base_reg, displ, 0, 0, dst_reg, x64_BYTE);
}

pload8_memu_con: PBLDU(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

}

reg: pload8_memu_con
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, dst_reg, x64_BYTE);
}


;1 byte unsigned
pload8_memiu_reg: PBLDU(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

}

reg: pload8_memiu_reg
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ, dst_reg, x64_DWORD);
	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, base_reg, dst_reg, x64_DWORD);
	//x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, dst_reg, 0, dst_reg, x64_BYTE);
	x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ,0, 0,  dst_reg, x64_BYTE);
}

mem: pload8_mem_con
{
}

mem: pload8_memu_con
{
}

memi: pload8_memi_reg
{
}
memi: pload8_memiu_reg
{
}

;16 bit...

pload16_smem_con: PSLDS(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

}


reg: pload16_smem_con
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVSX, base_reg, displ, dst_reg, x64_WORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, dst_reg, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, dst_reg, x64_DWORD);
}

;2 byte signed to swap
pload16_smemi_reg: PSLDS(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

}

reg: pload16_smemi_reg
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

//FIXME: we have to sign extend in both cases movsx is not enouth as then we swap bytes
	x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_MOVSX, base_reg, displ,0, 0,  dst_reg, x64_WORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, dst_reg, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, dst_reg, x64_DWORD);
}

pload16_smemu_con: PSLDU(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

}


reg: pload16_smemu_con
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, dst_reg, x64_WORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, dst_reg, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, dst_reg, x64_DWORD);
}

pload16_smemiu_reg: PSLDU(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

}

reg: pload16_smemiu_reg
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, 0, 0, dst_reg, x64_WORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, dst_reg, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, dst_reg, x64_DWORD);
}

smem: pload16_smemu_con
{
}

smem: pload16_smem_con
{
}

smemi: pload16_smemi_reg
{
}
smemi: pload16_smemiu_reg
{
}

;32bit............

pload32_smem_con: PILD(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 4, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

}

reg: pload32_smem_con
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, base_reg, displ, dst_reg, x64_DWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, dst_reg, x64_DWORD);
}

pload32_smemi_reg: PILD(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 4, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

}

reg: pload32_smemi_reg
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));


	x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_MOV, base_reg, displ, 0, 0, dst_reg, x64_DWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, dst_reg, x64_DWORD);
}

smem: pload32_smem_con
{
}

smemi: pload32_smemi_reg
{
}
;;;;;;;;;;;;;;;;; OTHER ;;;;;;;;;;;;;;;;;;;;;;;;

iload8_mem_con: ISSBLD(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

}

reg: iload8_mem_con
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVSX, base_reg, displ, dst_reg, x64_BYTE);
}

;1 byte signed
iload8_memi_reg: ISSBLD(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

}

reg: iload8_memi_reg
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ, dst_reg, x64_DWORD);
	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, base_reg, dst_reg, x64_DWORD);
	//x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVSX, dst_reg, 0, dst_reg, x64_BYTE);

	x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_MOVSX, base_reg, displ, 0, 0, dst_reg, x64_BYTE);
}

iload8_memu_con: ISBLD(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

}

reg: iload8_memu_con
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, dst_reg, x64_BYTE);
}

;1 byte unsigned
iload8_memiu_reg: ISBLD(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

}

reg: iload8_memiu_reg
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ, dst_reg, x64_DWORD);
	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, base_reg, dst_reg, x64_DWORD);
	//x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, dst_reg, 0, dst_reg, x64_BYTE);
	x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, 0, 0, dst_reg, x64_BYTE);
}

iload8_memi_reg: iload8_memiu_reg
{
}

iload8_mem_con: iload8_memu_con
{
}

memi: iload8_memi_reg
{
}

mem: iload8_mem_con
{
}
;16 bit...............

iload16_mem_con: ISSSLD(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

}

reg: iload16_mem_con
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVSX, base_reg, displ, dst_reg, x64_WORD);
}

;2 byte signed
iload16_memi_reg: ISSSLD(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

}

reg: iload16_memi_reg
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ, dst_reg, x64_DWORD);
	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, base_reg, dst_reg, x64_DWORD);
	//x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVSX, dst_reg, 0, dst_reg, x64_WORD);
	x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_MOVSX, base_reg, displ, 0, 0, dst_reg, x64_WORD);

}

iload16_memu_con: ISSLD(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

}

reg: iload16_memu_con
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, dst_reg, x64_WORD);
}

iload16_memiu_reg: ISSLD(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

}

reg: iload16_memiu_reg
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ, dst_reg, x64_DWORD);
	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, base_reg, dst_reg, x64_DWORD);
	//x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, dst_reg, 0, dst_reg, x64_WORD);
	x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, 0, 0, dst_reg, x64_WORD);

}

iload16_mem_con: iload16_memu_con
{
}

iload16_memi_reg: iload16_memiu_reg
{
}

mem: iload16_mem_con
{
}

memi: iload16_memi_reg
{
}

;32 bit...............

iload32_mem_con: ISSILD(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 4, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

}

reg: iload32_mem_con
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, base_reg, displ, dst_reg, x64_DWORD);
}

iload32_memi_reg: ISSILD(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 4, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

}

reg: iload32_memi_reg
{
	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ, dst_reg, x64_DWORD);
	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, base_reg, dst_reg, x64_DWORD);
	//x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, dst_reg, 0, dst_reg, x64_DWORD);

	x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, 0, 0, dst_reg, x64_DWORD);
}

mem: iload32_mem_con
{
}

memi: iload32_memi_reg
{
}

reg: DBLDS(reg)
{
NETVM_ASSERT(1==0, "data load/store not impl");
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE base_reg(MBTREE_VALUE(MBTREE_LEFT(tree)));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVSX, base_reg, data_base, dst_reg, x64_BYTE);
}

reg: DBLDS(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::data);
NETVM_ASSERT(1==0, "data load/store not impl");
	counter_access_mem_profiling( BB, x64_dim_man::data);

	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Displ_To_Reg(BB.getCode(), X64_MOVSX, data_base + displ, dst_reg, x64_BYTE);
}

reg: DBLDU(reg)
{
NETVM_ASSERT(1==0, "data load/store not impl");
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE base_reg(MBTREE_VALUE(MBTREE_LEFT(tree)));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, base_reg, data_base, dst_reg, x64_BYTE);
}

reg: DBLDU(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 1, x64_dim_man::data);
NETVM_ASSERT(1==0, "data load not impl");
	counter_access_mem_profiling( BB, x64_dim_man::data);

	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Displ_To_Reg(BB.getCode(), X64_MOVZX, data_base + displ, dst_reg, x64_BYTE);
}

reg: DSLDS(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 2 , x64_dim_man::data);
NETVM_ASSERT(1==0, "data load not impl");
	counter_access_mem_profiling( BB, x64_dim_man::data);

	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE base_reg(MBTREE_VALUE(MBTREE_LEFT(tree)));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVSX, base_reg, data_base, dst_reg, x64_WORD);
}

reg: DSLDS(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::data);
NETVM_ASSERT(1==0, "data load not impl");
	counter_access_mem_profiling( BB, x64_dim_man::data);

	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Displ_To_Reg(BB.getCode(), X64_MOVSX, data_base + displ, dst_reg, x64_WORD);
}

reg: DSLDU(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::data);
NETVM_ASSERT(1==0, "data load not impl");
	counter_access_mem_profiling( BB, x64_dim_man::data);

	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE base_reg(MBTREE_VALUE(MBTREE_LEFT(tree)));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, base_reg, data_base, dst_reg, x64_WORD);
}

reg: DSLDU(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 2, x64_dim_man::data);
NETVM_ASSERT(1==0, "data load not impl");
	counter_access_mem_profiling( BB, x64_dim_man::data);

	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Displ_To_Reg(BB.getCode(), X64_MOVZX, data_base + displ, dst_reg, x64_WORD);
}

reg: DILD(reg)
{
	//bounds_check_REG_IMM(cfg, BB, MBTREE_VALUE(MBTREE_LEFT(tree)) , 4, x64_dim_man::data);
NETVM_ASSERT(1==0, "data load not impl");
	counter_access_mem_profiling( BB, x64_dim_man::data);

	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE base_reg(MBTREE_VALUE(MBTREE_LEFT(tree)));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, base_reg, data_base, dst_reg, x64_DWORD);
}

reg: DILD(con)
{
	//bounds_check_IMM_IMM(cfg, BB, MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)) , 4, x64_dim_man::data);
NETVM_ASSERT(1==0, "data load not impl");
	counter_access_mem_profiling( BB, x64_dim_man::data);

	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dst_reg(MBTREE_VALUE(tree));

	x64_Asm_Op_Mem_Displ_To_Reg(BB.getCode(), X64_MOV, data_base + displ, dst_reg, x64_DWORD);
}

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;
; store to memory
;

;
; 1 BYTE
;

stmt: PBSTR(con, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	uint32_t value = MBTREE_GET_CONST_VALUE( MBTREE_RIGHT(tree) );
	uint32_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );

	//bounds_check_IMM_IMM(cfg, BB, displ , 1, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_BYTE);
}

stmt: PBSTR(reg, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	uint8_t value(MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree)));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 1, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

//	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );

//	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
//	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, reg, displ, x64_DWORD);
//	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, reg, baseReg, x64_DWORD);
//	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_BYTE);

	MBREG_TYPE reg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV,  displ, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD,  baseReg, reg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_BYTE);

}

stmt: PBSTR(con, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	uint32_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );

	//bounds_check_IMM_IMM(cfg, BB, displ , 1, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_BYTE);
}

stmt: PBSTR(reg, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 1, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_BYTE);
*/

	MBREG_TYPE reg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV,  displ, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD,  baseReg, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_BYTE);
}

;
; 2 BYTE
;

stmt: PSSTR(con, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	uint32_t value = MBTREE_GET_CONST_VALUE( MBTREE_RIGHT(tree) );
	uint16_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );
	value = nvm_htons(value);

	//bounds_check_IMM_IMM(cfg, BB, displ , 2, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_WORD);
}

stmt: PSSTR(reg, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	uint16_t value(MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree)));
	value = nvm_htons(value);

	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 2, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_WORD);
*/

	MBREG_TYPE reg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV,  displ, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD,  baseReg, reg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_BYTE);


}

stmt: PSSTR(con, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	uint32_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );

	//bounds_check_IMM_IMM(cfg, BB, displ , 2, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, value, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_WORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, value, x64_DWORD);
}

stmt: PSSTR(reg, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 2, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, value, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_WORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, value, x64_DWORD);
*/

	MBREG_TYPE reg(X64_NEW_VIRT_REG);

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV,  displ, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, baseReg, reg, x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, value, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_WORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, value, x64_DWORD);
}

;
; 4 BYTE
;

stmt: PISTR(con, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	uint32_t value = MBTREE_GET_CONST_VALUE( MBTREE_RIGHT(tree) );
	uint32_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );
	value = nvm_htonl(value);

	//bounds_check_IMM_IMM(cfg, BB, displ , 4, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_DWORD);
}

stmt: PISTR(reg, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	uint32_t value(MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree)));
	value = nvm_htonl(value);

	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 4, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );


	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_DWORD);
*/

	MBREG_TYPE  reg(X64_NEW_VIRT_REG); \
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV,  displ, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, baseReg, reg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_DWORD);

}

stmt: PISTR(con, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	uint32_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );

	//bounds_check_IMM_IMM(cfg, BB, displ , 4, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_DWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
}

stmt: PISTR(reg, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 4, x64_dim_man::packet);

	counter_access_mem_profiling( BB, x64_dim_man::packet);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_DWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);

*/
	MBREG_TYPE reg(X64_NEW_VIRT_REG);

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ, reg,  x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, baseReg, reg, x64_QWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_DWORD);
	x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, value, x64_DWORD);
}

;;;;;;;;;;;;;;;;;;;;;;; STORE OTHER MEMORY ;;;;;;;;;;;;;;;;;;;;;;;;;;;;

stmt: IBSTR(con, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	uint32_t value = MBTREE_GET_CONST_VALUE( MBTREE_RIGHT(tree) );
	uint32_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );

	//bounds_check_IMM_IMM(cfg, BB, displ , 1, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_BYTE);
}

stmt: IBSTR(reg, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	uint8_t value(MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree)));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 1, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );
//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_BYTE);
*/
	MBREG_TYPE reg(X64_NEW_VIRT_REG);

	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, displ, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, baseReg, reg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_BYTE);


}

stmt: IBSTR(con, reg)
{


	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	uint32_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );

	//bounds_check_IMM_IMM(cfg, BB, displ , 1, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_BYTE);
}

stmt: IBSTR(reg, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 1, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, value, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_BYTE);
*/
	MBREG_TYPE reg(X64_NEW_VIRT_REG);

	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, displ, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, baseReg, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_BYTE);
}



stmt: ISSTR(con, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	uint32_t value = MBTREE_GET_CONST_VALUE( MBTREE_RIGHT(tree) );
	uint16_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );

	//bounds_check_IMM_IMM(cfg, BB, displ , 2, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_WORD);
}

stmt: ISSTR(reg, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	uint16_t value(MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree)));

	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));


	//bounds_check_REG_IMM(cfg, BB, displ , 2, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );

	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_WORD);
*/

	MBREG_TYPE reg(X64_NEW_VIRT_REG);

	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, displ,  reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, baseReg,  reg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_WORD);

}

stmt: ISSTR(con, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	uint32_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );

	//bounds_check_IMM_IMM(cfg, BB, displ , 2, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_WORD);
}

stmt: ISSTR(reg, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 2 , x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_WORD);
*/

	MBREG_TYPE reg(X64_NEW_VIRT_REG);

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD,  baseReg, reg,  x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_WORD);

}

;
; 4 BYTE
;

stmt: IISTR(con, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	uint32_t value = MBTREE_GET_CONST_VALUE( MBTREE_RIGHT(tree) );
	uint32_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );

	//bounds_check_IMM_IMM(cfg, BB, displ , 4, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_DWORD);
}

stmt: IISTR(reg, con)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	uint32_t value(MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree)));

	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 4, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );
	//x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_DWORD);
*/

	MBREG_TYPE reg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_MOV, displ, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(),  X64_ADD, baseReg, reg,  x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_DWORD);
}

stmt: IISTR(con, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	uint32_t displ = MBTREE_GET_CONST_VALUE( MBTREE_LEFT(tree) );

	//bounds_check_IMM_IMM(cfg, BB, displ , 4, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, baseReg, displ, x64_DWORD);
}

stmt: IISTR(reg, reg)
{
	MBREG_TYPE baseReg(x64_base_address_man::load_base(cfg, x64_base_address_man::info ));
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 4, x64_dim_man::info);

	counter_access_mem_profiling( BB, x64_dim_man::info);

/*
	MBREG_TYPE reg( MBREG_TYPE::get_new(REG_SPACE) );
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, reg, displ, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, reg, baseReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_DWORD);
*/

	MBREG_TYPE reg(X64_NEW_VIRT_REG);

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, displ,  reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_ADD, baseReg, reg, x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, reg, 0, x64_DWORD);
}

;
; ;;;;;;;;;;;;;;;; DATA ;;;;;;;;;;;;;;;;,,;;;;;;;
;

stmt: DBSTR(con, con)
{
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	uint32_t value = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;

	//MBREG_TYPE src_reg(MBTREE_VALUE(MBTREE_RIGHT(tree)));

	//bounds_check_IMM_IMM(cfg, BB, displ , 1, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);
	
	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_BYTE);
}

stmt: DBSTR(con, reg)
{
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));

	//bounds_check_IMM_IMM(cfg, BB, displ , 1, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_BYTE);
}

stmt: DBSTR(reg, con)
{
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	uint32_t value = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

	//bounds_check_REG_IMM(cfg, BB, displ , 1, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);
	
	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Index(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_BYTE);
}

stmt: DBSTR(reg, reg)
{
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 1, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Index(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_BYTE);
}

stmt: DSSTR(con, con)
{
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	uint32_t value = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;

	//MBREG_TYPE src_reg(MBTREE_VALUE(MBTREE_RIGHT(tree)));

	//bounds_check_IMM_IMM(cfg, BB, displ , 2, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_WORD);
}

stmt: DSSTR(con, reg)
{
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));

	//bounds_check_IMM_IMM(cfg, BB, displ , 2, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_WORD);
}

stmt: DSSTR(reg, con)
{
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	uint32_t value = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

	//bounds_check_REG_IMM(cfg, BB, displ , 2, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Index(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_WORD);
}

stmt: DSSTR(reg, reg)
{
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 2, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Index(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_WORD);
}

stmt: DISTR(con, con)
{
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	uint32_t value = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;

	//MBREG_TYPE src_reg(MBTREE_VALUE(MBTREE_RIGHT(tree)));

	//bounds_check_IMM_IMM(cfg, BB, displ , 4, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_DWORD);
}

stmt: DISTR(con, reg)
{
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));

	//bounds_check_IMM_IMM(cfg, BB, displ , 4, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_DWORD);
}

stmt: DISTR(reg, con)
{
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	uint32_t value = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

	//bounds_check_REG_IMM(cfg, BB, displ , 4, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Imm_To_Mem_Index(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_DWORD);
}

stmt: DISTR(reg, reg)
{
	MBREG_TYPE displ(MBTREE_VALUE(MBTREE_LEFT(tree)));
	uint64_t data_base = (uint64_t)APPLICATION.getMemDescriptor(Application::data).Base;
	MBREG_TYPE value(MBTREE_VALUE(MBTREE_RIGHT(tree)));

	//bounds_check_REG_IMM(cfg, BB, displ , 4, x64_dim_man::data);

	counter_access_mem_profiling( BB, x64_dim_man::data);

	MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, data_base, tmpReg, x64_QWORD);
	x64_Asm_Op_Reg_To_Mem_Index(BB.getCode(), X64_MOV, value, tmpReg, displ, x64_DWORD);
}

reg: LDREG
{
	MBREG_TYPE reg = MBTREE_VALUE(tree);

	if(reg.get_model()->get_space() == APPLICATION.getCoprocessorRegSpace())
	{
		MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
		MBREG_TYPE dstReg(X64_NEW_VIRT_REG);
		tree->setDefReg(dstReg);

		uint32_t regname = reg.get_model()->get_name();
		uint32_t coproId = regname / MAX_COPRO_REGISTERS;
		uint32_t coproReg = regname % MAX_COPRO_REGISTERS;

		nvmCoprocessorState* copro = APPLICATION.getCoprocessor(coproId);

#ifdef _EXP_COPROCESSOR_MODEL
		if (strcmp(copro->name, "lookupnew") == 0 && coproReg == 7)
		{
			NETVM_ASSERT(1 == 0, "NOT IMPLEMENTED!!!")
			x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, newReg, dstReg, x64_DWORD);
		}
		else
		{
#endif

		uint64_t regAddr = (uint64_t)&copro->registers[coproReg];
		//FIXME: on x86 code this was only 1 op (maybe there's a way to do also on x64 code)
		x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, regAddr, tmpReg, x64_QWORD);
		x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, tmpReg, 0, dstReg, x64_DWORD);

#ifdef _EXP_COPROCESSOR_MODEL
		}
#endif

	}
#ifdef _DEBUG_X64_INSSEL
	printf("\t[LDREG %d]\t;LDREG\n", REG_NAME(MBTREE_VALUE(tree)));
#endif
}

reg: PBL
{

//MBREG_TYPE reg(x64_dim_man::load_dim(cfg, x64_dim_man::packet));

	MBREG_TYPE reg = MBTREE_VALUE(tree);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, x64_dim_man::load_dim(cfg, x64_dim_man::packet), reg, x64_DWORD);

/*

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(EBP), 8, reg, x64_DWORD);
	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, reg, 0, reg, x64_DWORD);
	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, reg, x64_offsets.ExchangeBuffer.PacketLen, reg, x64_DWORD);
*/

}

reg: TSTAMP_S
{
	MBREG_TYPE reg = MBTREE_VALUE(tree);

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(RBP), 8, reg, x64_QWORD);
	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, reg, 0, reg, x64_QWORD);
	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, reg, x64_offsets.ExchangeBuffer.TStamp_s, reg, x64_QWORD);
}

reg: TSTAMP_US
{
	MBREG_TYPE reg = MBTREE_VALUE(tree);

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(RBP), 8, reg, x64_QWORD);
	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, reg, 0, reg, x64_QWORD);
	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, reg, x64_offsets.ExchangeBuffer.TStamp_us, reg, x64_QWORD);
}

reg: IINC_1(con),
reg: IDEC_1(con)
{
	uint32_t imm = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64OpCodesEnum opcode = get_alu_opcode(tree);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV R%d, %d\t;%s(reg)\n", REG_NAME(dstReg), imm, x64OpDescriptions[OP_ONLY(opcode)].Name);
	printf("\t%s R%d     \t;%s(reg)\n", x64OpDescriptions[OP_ONLY(opcode)].Name, REG_NAME(dstReg), x64OpDescriptions[OP_ONLY(opcode)].Name);
#endif

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, imm, dstReg, x64_DWORD);
	x64_Asm_Op_Reg(BB.getCode(), opcode, dstReg, x64_DWORD);
}

reg: IINC_1(reg),
reg: IDEC_1(reg),
reg: NEG(reg)
{
	MBREG_TYPE srcReg = MBTREE_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64OpCodesEnum opcode = get_alu_opcode(tree);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV R%d, R%d\t;%s(reg)\n", REG_NAME(dstReg), REG_NAME(srcReg), x64OpDescriptions[OP_ONLY(opcode)].Name);
	printf("\t%s R%d     \t;%s(reg)\n", x64OpDescriptions[OP_ONLY(opcode)].Name, REG_NAME(dstReg), x64OpDescriptions[OP_ONLY(opcode)].Name);
#endif

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, dstReg, x64_DWORD);
	x64_Asm_Op_Reg(BB.getCode(), opcode, dstReg, x64_DWORD);
}

reg: SHR(reg, con),
reg: USHR(reg, con)
{
	uint32_t imm = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE srcReg = MBTREE_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64OpCodesEnum opcode = get_alu_opcode(tree);

#ifdef _DEBUG_X64_INSSEL
	char *name = x64OpDescriptions[OP_ONLY(opcode)].Name;

	printf("\tMOV R%d, %d\t;%s(reg, reg)", REG_NAME(dstReg), imm, name);
	printf("\tMOV ECX, R%d\t;%s(reg, reg)", REG_NAME(srcReg), name);
	printf("\t%s R%d, ECX\t;%s(reg, reg)", name, REG_NAME(dstReg), name);
#endif

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, dstReg, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), opcode, imm, dstReg, x64_DWORD);

}

reg: SHR(con, reg),
reg: USHR(con, reg)
{
	uint32_t imm = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE srcReg = MBTREE_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64OpCodesEnum opcode = get_alu_opcode(tree);

	//Have to move the count to ECX

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, imm, dstReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), opcode, X64_MACH_REG(ECX), dstReg, x64_DWORD);

}

reg: SHR(reg, reg),
reg: USHR(reg, reg)
{
	MBREG_TYPE srcReg1 = MBTREE_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE srcReg2 = MBTREE_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64OpCodesEnum opcode = get_alu_opcode(tree);

#ifdef _DEBUG_X64_INSSEL
	char *name = x64OpDescriptions[OP_ONLY(opcode)].Name;

	printf("\tMOV R%d, R%d\t;%s(reg, reg)", REG_NAME(dstReg), REG_NAME(srcReg2), name);
	printf("\tMOV ECX, R%d\t;%s(reg, reg)", REG_NAME(srcReg1), name);
	printf("\t%s R%d, ECX\t;%s(reg, reg)", name, REG_NAME(dstReg), name);
#endif

	//Have to move the count to ECX

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg1, dstReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg2, X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), opcode, X64_MACH_REG(ECX), dstReg, x64_DWORD);
}



reg: SHL(reg, con)
{
	uint32_t imm = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE srcReg = MBTREE_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64OpCodesEnum opcode = get_alu_opcode(tree);

#ifdef _DEBUG_X64_INSSEL
	char *name = x64OpDescriptions[OP_ONLY(opcode)].Name;

	printf("\tMOV R%d, %d\t;%s(reg, reg)", REG_NAME(dstReg), imm, name);
	printf("\tMOV ECX, R%d\t;%s(reg, reg)", REG_NAME(srcReg), name);
	printf("\t%s R%d, ECX\t;%s(reg, reg)", name, REG_NAME(dstReg), name);
#endif

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, dstReg, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), opcode, imm, dstReg, x64_DWORD);

}

reg: SHL(con, reg)
{
	uint32_t imm = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE srcReg = MBTREE_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64OpCodesEnum opcode = get_alu_opcode(tree);

	//Have to move the count to ECX

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, imm, dstReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), opcode, X64_MACH_REG(ECX), dstReg, x64_DWORD);

}

reg: SHL(reg, reg)
{
	MBREG_TYPE srcReg1 = MBTREE_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE srcReg2 = MBTREE_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64OpCodesEnum opcode = get_alu_opcode(tree);

#ifdef _DEBUG_X64_INSSEL
	char *name = x64OpDescriptions[OP_ONLY(opcode)].Name;

	printf("\tMOV R%d, R%d\t;%s(reg, reg)", REG_NAME(dstReg), REG_NAME(srcReg2), name);
	printf("\tMOV ECX, R%d\t;%s(reg, reg)", REG_NAME(srcReg1), name);
	printf("\t%s R%d, ECX\t;%s(reg, reg)", name, REG_NAME(dstReg), name);
#endif

	//Have to move the count to ECX

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg1, dstReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg2, X64_MACH_REG(ECX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), opcode, X64_MACH_REG(ECX), dstReg, x64_DWORD);
}








reg: ADDUOV(reg, reg),
reg: ADD(reg, reg),
reg: SUBUOV(reg, reg),
reg: SUB(reg, reg),
reg: AND(reg, reg),
reg: OR(reg, reg)
{
	MBREG_TYPE dstReg  = MBTREE_VALUE(tree);
	MBREG_TYPE srcReg0 = MBTREE_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE srcReg1 = MBTREE_VALUE(MBTREE_RIGHT(tree));

	x64OpCodesEnum opcode = get_alu_opcode(tree);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV R%d, R%d\t;%s(reg, reg)\n", REG_NAME(dstReg), REG_NAME(srcReg1), x64OpDescriptions[OP_ONLY(opcode)].Name);
	printf("\t%s R%d, R%d\t;%s(reg, reg)\n", x64OpDescriptions[OP_ONLY(opcode)].Name, REG_NAME(dstReg), REG_NAME(srcReg0), x64OpDescriptions[OP_ONLY(opcode)].Name);
#endif

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg0, dstReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), opcode,  srcReg1, dstReg, x64_DWORD);

}


reg: NOT(reg)
{

	MBREG_TYPE dstReg  = MBTREE_VALUE(tree);
	MBREG_TYPE srcReg = MBTREE_VALUE(MBTREE_LEFT(tree));

	x64OpCodesEnum opcode = get_alu_opcode(tree);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, dstReg, x64_DWORD);
	x64_Asm_Op_Reg(BB.getCode(), opcode, dstReg, x64_DWORD);
}



reg: SUBUOV(reg, con),
reg: SUB(reg, con)
{

	MBREG_TYPE dstReg  = MBTREE_VALUE(tree);
	MBREG_TYPE srcReg  = MBTREE_VALUE(MBTREE_LEFT(tree));
	uint32_t imm = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

	x64OpCodesEnum opcode = get_alu_opcode(tree);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV R%d, %d\t;%s(reg, con)\n", REG_NAME(dstReg),  REG_NAME(srcReg), x64OpDescriptions[OP_ONLY(opcode)].Name);
	printf("\t%s R%d, R%d\t;%s(reg, con)\n", x64OpDescriptions[OP_ONLY(opcode)].Name, REG_NAME(dstReg), imm, x64OpDescriptions[OP_ONLY(opcode)].Name);
#endif


 	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, dstReg, x64_DWORD);
  	x64_Asm_Op_Imm_To_Reg(BB.getCode(),  opcode, imm, dstReg, x64_DWORD);


}

reg: OR(reg, con),
reg: AND(reg, con),
reg: ADD(reg, con),
reg: ADDUOV(reg, con)
{
	MBREG_TYPE dstReg  = MBTREE_VALUE(tree);
	MBREG_TYPE srcReg  = MBTREE_VALUE(MBTREE_LEFT(tree));
	uint32_t imm = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

	x64OpCodesEnum opcode = get_alu_opcode(tree);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV R%d, R%d\t;%s(reg, con)\n", REG_NAME(dstReg), REG_NAME(srcReg), x64OpDescriptions[OP_ONLY(opcode)].Name);
	printf("\t%s R%d, %d\t;%s(reg, con)\n", x64OpDescriptions[OP_ONLY(opcode)].Name, REG_NAME(dstReg), imm, x64OpDescriptions[OP_ONLY(opcode)].Name);
#endif

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, dstReg, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), opcode, imm, dstReg, x64_DWORD);
}

reg: OR(con, con),
reg: AND(con, con),
reg: SUB(con, con),
reg: SUBUOV(con, con),
reg: ADDUOV(con, con),
reg: ADD(con, con),
reg: SHR(con, con),
reg: USHR(con, con)
{
	MBREG_TYPE dstReg  = MBTREE_VALUE(tree);
	uint32_t src0 = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	uint32_t src1 = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

	x64OpCodesEnum opcode = get_alu_opcode(tree);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV R%d, %d\t;%s(con, con)\n", REG_NAME(dstReg), src1, x64OpDescriptions[OP_ONLY(opcode)].Name);
	printf("\t%s R%d, %d\t;%s(con, con)\n", x64OpDescriptions[OP_ONLY(opcode)].Name, REG_NAME(dstReg), src0, x64OpDescriptions[OP_ONLY(opcode)].Name);
#endif

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, src0, dstReg, x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(),  opcode, src1, dstReg, x64_DWORD);
}

reg: MOD(con, reg)
{
	uint32_t src1 = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE src2 = MBTREE_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64Regs_32 res = EDX;//(tree->getOpcode() == IMUL ?  EAX : EDX);
	x64OpCodesEnum opcode = X64_DIV;//(tree->getOpcode() == IMUL ? X64_MOV : X64_DIV);

#ifdef _DEBUG_X64_INSSEL
	printf("\tXOR EDX, EDXd\n");
	printf("\tMOV EAX, %d\n", src1);
	printf("\tMOV R%d, %d", REG_NAME(dstReg), REG_NAME(src2));
	printf("\t%s R%d\n", x64OpDescriptions[OP_ONLY(opcode)].Name, REG_NAME(dstReg));
	printf("\tMOV R%d, %s\n", REG_NAME(dstReg), x64RegNames[res + 16]);
#endif

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_XOR, X64_MACH_REG(EDX), X64_MACH_REG(EDX), x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, src1, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, src2, dstReg, x64_DWORD);

	x64_Asm_Op_Reg(BB.getCode(), opcode, dstReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(res), dstReg, x64_DWORD);
}

reg: IMUL(reg, con),
reg: MOD(reg, con)
{
	MBREG_TYPE src1 = MBTREE_VALUE(MBTREE_LEFT(tree));
	uint32_t src2 = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64Regs_32 res = (tree->getOpcode() == IMUL ?  EAX : EDX);
	x64OpCodesEnum opcode = (tree->getOpcode() == IMUL ? X64_MUL : X64_DIV);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV EAX, R%d\n", REG_NAME(src1));
	printf("\tMOV R%d, %d", REG_NAME(dstReg), src2);
	printf("\t%s R%d\n", x64OpDescriptions[OP_ONLY(opcode)].Name, REG_NAME(dstReg));
	printf("\tMOV R%d, %s\n", REG_NAME(dstReg), x64RegNames[res + 16]);
#endif

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, src1, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, src2, dstReg, x64_DWORD);

	x64_Asm_Op_Reg(BB.getCode(), opcode, dstReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(res), dstReg, x64_DWORD);
}

reg: IMUL(con, con),
reg: MOD(con, con)
{
	uint32_t src1 = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	uint32_t src2 = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64Regs_32 res = (tree->getOpcode() == IMUL ?  EAX : EDX);
	x64OpCodesEnum opcode = (tree->getOpcode() == IMUL ? X64_MUL : X64_DIV);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV EAX, %d\n", src1);
	printf("\tMOV R%d, %d", REG_NAME(dstReg), src2);
	printf("\t%s R%d\n", x64OpDescriptions[OP_ONLY(opcode)].Name, REG_NAME(dstReg));
	printf("\tMOV R%d, %s\n", REG_NAME(dstReg), x64RegNames[res + 16]);
#endif

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, src1, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, src2, dstReg, x64_DWORD);

	x64_Asm_Op_Reg(BB.getCode(), opcode, dstReg, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(res), dstReg, x64_DWORD);
}

reg: IMUL(reg, reg),
reg: MOD(reg, reg)
{
	MBREG_TYPE srcReg1 = MBTREE_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE srcReg2 = MBTREE_VALUE(MBTREE_RIGHT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	x64Regs_32 res = (tree->getOpcode() == IMUL ?  EAX : EDX);
	x64OpCodesEnum opcode = (tree->getOpcode() == IMUL ? X64_MUL : X64_DIV);

#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV EAX, R%d\n", REG_NAME(srcReg1));
	printf("\t%s R%d\n", x64OpDescriptions[OP_ONLY(opcode)].Name, REG_NAME(srcReg2));
	printf("\tMOV R%d, %s\n", REG_NAME(dstReg), x64RegNames[res + 16]);
#endif

	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg1, X64_MACH_REG(EAX), x64_DWORD);

	x64_Asm_Op_Reg(BB.getCode(), opcode, srcReg2, x64_DWORD);
	x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(res), dstReg, x64_DWORD);
}

reg: CMP(reg, reg)
{
std::cout << "CMP opcode not implemented\n";
}

reg: CMP(reg, con)
{
std::cout << "CMP opcode not implemented\n";
}

reg: CMP(con, reg)
{
std::cout << "CMP opcode not implemented\n";
}

stmt: STREG(reg)
{
	MBREG_TYPE srcReg = MBTREE_VALUE(MBTREE_LEFT(tree));
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);

	if(dstReg.get_model()->get_space() == APPLICATION.getCoprocessorRegSpace())
	{
		uint32_t regname = dstReg.get_model()->get_name();
		uint32_t coproId = regname / MAX_COPRO_REGISTERS;

		nvmCoprocessorState* copro = APPLICATION.getCoprocessor(coproId);

		uint32_t coproReg = regname % MAX_COPRO_REGISTERS;
		uint64_t regAddr = (uint64_t)&copro->registers[coproReg];

		MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
		x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, regAddr, tmpReg, x64_QWORD);
		x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, srcReg, tmpReg, 0, x64_DWORD);

	}
	else
	{
#ifdef _DEBUG_X64_INSSEL
		printf("\tMOV R%d, R%d\t; STREG(reg)\n", REG_NAME(dstReg), REG_NAME(srcReg));
#endif

		x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, srcReg, dstReg, x64_DWORD);
	}
}

stmt: STREG(con)
{
	MBREG_TYPE dstReg = MBTREE_VALUE(tree);
	uint32_t value  = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));

	if(dstReg.get_model()->get_space() == APPLICATION.getCoprocessorRegSpace())
	{
		uint32_t regname = dstReg.get_model()->get_name();
		uint32_t coproId = regname / MAX_COPRO_REGISTERS;
		uint32_t coproReg = regname % MAX_COPRO_REGISTERS;

		nvmCoprocessorState* copro = APPLICATION.getCoprocessor(coproId);
		uint64_t regAddr = (uint64_t)&copro->registers[coproReg];

		MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
		x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, regAddr, tmpReg, x64_QWORD);
		x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_MOV, value, tmpReg, 0, x64_DWORD);
	}
	else
	{
#ifdef _DEBUG_X64_INSSEL
	printf("\tMOV R%d, %d\t; STREG(con)\n", REG_NAME(dstReg), value);
#endif

	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, value, dstReg, x64_DWORD);
	}
}

%ifdef _EXP_COPROCESSOR_MODEL
stmt: STREG(PSLDU(con))
{
	MBREG_TYPE dst_reg = MBTREE_VALUE(tree);


	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, MBTREE_LEFT(tree)));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(MBTREE_LEFT(tree)));
	MBREG_TYPE tmp_dst_reg(MBTREE_VALUE(MBTREE_LEFT(tree)));

#ifdef _DEBUG_X64_INSSEL
	printf("\tSTREG(PSLDU(con))\n");
#endif

	if(dst_reg.get_model()->get_space() == APPLICATION.getCoprocessorRegSpace())
	{
		uint32_t regname = dst_reg.get_model()->get_name();
		uint32_t coproId = regname / MAX_COPRO_REGISTERS;
		uint32_t coproReg = regname % MAX_COPRO_REGISTERS;

		nvmCoprocessorState* copro = APPLICATION.getCoprocessor(coproId);
		uint64_t regAddr = (uint64_t)&copro->registers[coproReg];

		if (strcmp(copro->name, "lookupnew") == 0)
		{
			MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
			x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, regAddr, tmpReg, x64_QWORD);
			x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, tmp_dst_reg, x64_WORD);
			x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, tmp_dst_reg, tmpReg, 0, x64_DWORD);
		}
		else
		{
			x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, dst_reg, x64_WORD);
			x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, dst_reg, x64_DWORD);
			x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, dst_reg, x64_DWORD);
		}
	}
	else
	{

		x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, dst_reg, x64_WORD);
		x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, dst_reg, x64_DWORD);
		x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_SHR, 16, dst_reg, x64_DWORD);

	}
}


stmt: STREG(PILD(con))
{


	MBREG_TYPE dst_reg = MBTREE_VALUE(tree);


	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, MBTREE_LEFT(tree)));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(MBTREE_LEFT(tree)));
	MBREG_TYPE tmp_dst_reg(MBTREE_VALUE(MBTREE_LEFT(tree)));

#ifdef _DEBUG_X64_INSSEL
	printf("\tSTREG(PILD(con))\n");
#endif


	if(dst_reg.get_model()->get_space() == APPLICATION.getCoprocessorRegSpace())
	{
		uint32_t regname = dst_reg.get_model()->get_name();
		uint32_t coproId = regname / MAX_COPRO_REGISTERS;
		uint32_t coproReg = regname % MAX_COPRO_REGISTERS;

		nvmCoprocessorState* copro = APPLICATION.getCoprocessor(coproId);
		uint64_t regAddr = (uint64_t)&copro->registers[coproReg];

		if (strcmp(copro->name, "lookupnew") == 0)
		{
			MBREG_TYPE tmpReg(X64_NEW_VIRT_REG);
			x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, regAddr, tmpReg, x64_QWORD);
			x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, base_reg, displ, tmp_dst_reg, x64_DWORD);
			x64_Asm_Op_Reg_To_Mem_Base(BB.getCode(), X64_MOV, tmp_dst_reg, tmpReg, x64_DWORD);
		}
		else
		{
			x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, base_reg, displ, dst_reg, x64_DWORD);
			x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, dst_reg, x64_DWORD);
		}

	}
	else
	{
		x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOV, base_reg, displ, dst_reg, x64_DWORD);
		x64_Asm_Op_Reg(BB.getCode(), X64_BSWAP, dst_reg, x64_DWORD);
	}
}
%endif

stmt: reg
{
	std::cout << "!!!reg!!!";
}

stmt: con
{
	std::cout << "!!!con!!!";
}

stmt: PHI
{
	#ifdef _DEBUG_X64_INSSEL
	std::cout << "PHI" << std::endl;
	#endif
}

stmt: JUMP,
stmt: JUMPW
{
	JumpMIRNode* insn = dynamic_cast<JumpMIRNode*>(tree);
	assert(insn !=  NULL);

	uint32_t jt = insn->getTrueTarget();
#ifdef _DEBUG_X64_INSSEL
	printf("\tJUMP L%d\t;JUMPW\n", jt);
#endif

	x64_Asm_JMP_Label(BB.getCode(), jt);
}

stmt: SWITCH(reg)
{
	SwitchMIRNode* insn = dynamic_cast<SwitchMIRNode*>(tree);
	assert(insn != NULL);

	if(insn->get_targets_num() > 3)
	{
		x64SwitchHelper helper(BB, *insn);
		SwitchEmitter sw(helper, *insn);

		sw.run();
                x64_Asm_JMP_Label(BB.getCode(), insn->getDefaultTarget());
	}
	else
	{

		MBREG_TYPE reg = MBTREE_VALUE(MBTREE_LEFT(insn));

		SwitchMIRNode::targets_iterator i;
		for(i = insn->TargetsBegin(); i != insn->TargetsEnd(); i++)
		{
#ifdef _DEBUG_X64_INSSEL
			printf("\tCMP R%d, %d\t;SWITCH(reg)\n", REG_NAME(reg), i->first);
			printf("\tJEQ %d\t;SWITCH(reg)\n", i->second);
#endif
			x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, i->first, reg, x64_DWORD);
			x64_Asm_J_Label(BB.getCode(), E, i->second);
		}

		x64_Asm_JMP_Label(BB.getCode(), insn->getDefaultTarget());
	}
}

stmt: SWITCH(con)
{
	SwitchMIRNode* insn = dynamic_cast<SwitchMIRNode*>(tree);
	assert(insn != NULL);

	uint32_t value= MBTREE_GET_CONST_VALUE(MBTREE_LEFT(tree));
	uint16_t target;

	SwitchMIRNode::targets_iterator i;
	for(i = insn->TargetsBegin();
		i != insn->TargetsEnd() && i->first != value;
		i++);

	if(i == insn->TargetsEnd())
		target = insn->getDefaultTarget();
	else
		target = i->second;

#ifdef _DEBUG_X64_INSSEL
	printf("\tJMP %d\t;SWITCH(con)\n", target);
#endif

	x64_Asm_JMP_Label(BB.getCode(), target);
}

%ifdef SWAP_CONST
stmt: JCMPNEQ ( AND ( pload16_smemu_con, con ), con )
{
	JumpMIRNode* jump = dynamic_cast<JumpMIRNode*>(tree);
	assert(jump != NULL);
	uint32_t target = jump->getTrueTarget();

	MBTREE_TYPE* and_insn(MBTREE_LEFT(jump));
	MBTREE_TYPE* load(MBTREE_LEFT(and_insn));

	MBREG_TYPE tmp = MBTREE_VALUE(and_insn);
	uint16_t mask = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(and_insn));
	uint32_t cmp_const = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));

	MBREG_TYPE base_reg(x64_base_address_man::load_base(cfg, x64_base_address_man::packet));
	uint32_t displ = MBTREE_GET_CONST_VALUE(MBTREE_LEFT(load));

	x64_Asm_Op_Mem_Base_To_Reg(BB.getCode(), X64_MOVZX, base_reg, displ, tmp, x64_WORD);
	mask = nvm_htons(mask);
	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_AND, mask, tmp, x64_DWORD);
	if(cmp_const != 0)
	{
		cmp_const = nvm_htonl(cmp_const);
		x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_CMP, cmp_const, tmp, x64_DWORD);
	}
	x64_Asm_J_Label(BB.getCode(), NE, target);
}

reg: ADD ( IMUL ( reg, con), con)
{
	MBTREE_TYPE* mul = MBTREE_LEFT(tree);
	MBREG_TYPE src(MBTREE_VALUE(MBTREE_LEFT(mul)));
	uint32_t mul_con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(mul));
	uint32_t add_con = MBTREE_GET_CONST_VALUE(MBTREE_RIGHT(tree));


	MBREG_TYPE dst = MBTREE_VALUE(tree);

	if(mul_con == 4 || mul_con == 8)
	{
		uint32_t scale;
		switch(mul_con)
		{
			case 4:
				scale = 2;
				break;
			case 8:
				scale = 3;
				break;
		}
		x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_XOR, dst, dst, x64_DWORD);
		x64_Asm_Op_Mem_Index_To_Reg(BB.getCode(), X64_LEA, dst, src, add_con, scale, dst, x64_DWORD);
	}
	else
	{
		x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, src, X64_MACH_REG(EAX), x64_DWORD);
		x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, mul_con, dst, x64_DWORD);

		x64_Asm_Op_Reg(BB.getCode(), X64_MUL, dst, x64_DWORD);
		x64_Asm_Op_Reg_To_Reg(BB.getCode(), X64_MOV, X64_MACH_REG(EAX), dst, x64_DWORD);
		x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, add_con, dst, x64_DWORD);
	}
}

%endif

;reg: con
;{
;	MBREG_TYPE reg(RegisterInstance::get_new(REG_SPACE));
;	uint32_t value = MBTREE_GET_CONST_VALUE(tree);
;
;	x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_MOV, value, reg, x64_DWORD);
;	tree->setDefReg(reg);
;}
%%

jit::nvmStructOffsets<uint64_t> jit::x64::x64_offsets;
jit::x64::x64_base_address_man  jit::x64::base_manager;
jit::x64::x64_dim_man  jit::x64::dim_manager;

jit::x64::x64ConditionCodes jit::x64::get_cond_code(JumpMIRNode* insn, bool leftConst)
{
	assert(insn != NULL);
	switch(insn->getOpcode())
	{
		case JNE:
		case JCMPNEQ:
		case JFLDNEQ:
			return NE;
			break;
		case JCMPGE:
			if (leftConst)
				return L;
			return GE;
			break;
		case JCMPG:
		case JFLDGT:
			if (leftConst)
				return LE;
			return G;
			break;
		case JCMPL:
		case JFLDLT:
			if (leftConst)
				return GE ;
			return L ;
			break;
		case JCMPLE:
			if (leftConst)
				return G ;
			return LE;

			break;
		case JCMPEQ:
		case JEQ:
		case JFLDEQ:
			return E;
			break;
		default:
			assert(1 == 0 && "jump opcode invalid");
			;
	}
}

x64OpCodesEnum jit::x64::get_alu_opcode(MIRNode* insn)
{
	assert(insn != NULL);

	x64OpCodesEnum res;

	switch(insn->getOpcode())
	{
		case ADD:
		case ADDUOV:
			res = X64_ADD;
			break;
		case SUB:
		case SUBUOV:
			res = X64_SUB;
			break;
		case AND:
			res = X64_AND;
			break;
		case OR:
			res = X64_OR;
			break;
		case IINC_1:
			res = X64_INC;
			break;
		case IDEC_1:
			res = X64_DEC;
			break;
		case SHR:
			res = X64_SHR;
			break;
		case USHR:
			res = X64_SHR;
			break;
		case SHL:
			res = X64_SHL;
			break;
		case NEG:
			res = X64_NEG;
			break;
		case NOT:
			res = X64_NOT;
			break;
		default:
			assert(1 == 0 && "alu opcode invalid");
			;
	}

	return res;
}

void jit::x64::store_coprocessors_regs(BasicBlock<x64Instruction>& BB, CopMIRNode* insn)
{
	assert(insn != NULL);

	nvmCoprocessorState* copro = APPLICATION.getCoprocessor(insn->getcoproId());
	uint64_t read_func_addr = (uint64_t)copro->read;

	for(uint32_t i(0); i < insn->regNo(); ++i) {
		if(insn->isDefdReg(i)) {
			MBREG_TYPE dst = insn->getCoproReg(i, false);
#ifdef _DEBUG_X64_INSSEL
			printf("\tADD ESP, -4\t;Place to save value\n");
			printf("\tPUSH ESP\t;Place to save value\n");
			printf("\tPUSH %d\t;register Id\n", i);
			printf("\tPUSH 0x%x\t;coprocessor state address\n", (uint64_t)copro);
			printf("\tCALL 0x%x\t;read function address\n", read_func_addr);
			printf("\tADD ESP, 12\n");
			printf("\tPOP R%d\t;il valore era sullo stack\n", REG_NAME(dst));
#endif

  NETVM_ASSERT(1==0, "store_coprocessors_regs not impl");
			x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, -4, X64_MACH_REG(ESP), x64_DWORD);

			x64_Asm_Op(BB.getCode(), X64_SAVEREGS);

			x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(ESP), x64_DWORD);
			x64_Asm_Op_Imm_To_Mem_Base(BB.getCode(), X64_ADD, 12, X64_MACH_REG(ESP), 0, x64_DWORD);
			x64_Asm_Op_Imm(BB.getCode(), X64_PUSH, i);
			x64_Asm_Op_Imm(BB.getCode(), X64_PUSH, (uint64_t)copro);
			x64_Asm_Op_Imm(BB.getCode(), X64_CALL, read_func_addr);
			x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, 12, X64_MACH_REG(ESP), x64_DWORD);

			x64_Asm_Op(BB.getCode(), X64_LOADREGS);
			x64_Asm_Op_Reg(BB.getCode(), X64_POP, dst, x64_DWORD);
		}
	}
}

void jit::x64::load_coprocessors_regs(BasicBlock<x64Instruction>& BB, CopMIRNode* insn)
{
	assert(insn != NULL);

	nvmCoprocessorState* copro = APPLICATION.getCoprocessor(insn->getcoproId());
	uint64_t write_func_addr = (uint64_t)copro->write;
	MBREG_TYPE dst = MBTREE_VALUE(insn);

	for(uint32_t i(0); i < insn->regNo(); ++i) {
		if(insn->isUsedReg(i)) {
			MBREG_TYPE src = insn->getCoproReg(i, true);

#ifdef _DEBUG_X64_INSSEL
			printf("\tPUSH R%d\t;push value to write\n", REG_NAME(src));
			printf("\tPUSH ESP\t;address of value to write\n");
			printf("\tPUSH %d\t;register Id\n", i);
			printf("\tPUSH 0x%x\t;coprocessor state address\n", (uint64_t)copro);
			printf("\tCALL 0x%x\t;write function address\n", write_func_addr);
			printf("\tADD ESP, 16\n");
#endif

  NETVM_ASSERT(1==0, "load_coprocessors_regs not impl");
			x64_Asm_Op(BB.getCode(), X64_SAVEREGS);

			x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, src, x64_DWORD);
			x64_Asm_Op_Reg(BB.getCode(), X64_PUSH, X64_MACH_REG(ESP), x64_DWORD);
			x64_Asm_Op_Imm(BB.getCode(), X64_PUSH, i);
			x64_Asm_Op_Imm(BB.getCode(), X64_PUSH, (uint64_t)copro);
			x64_Asm_Op_Imm(BB.getCode(), X64_CALL, write_func_addr);
			x64_Asm_Op_Imm_To_Reg(BB.getCode(), X64_ADD, 16, X64_MACH_REG(ESP), x64_DWORD);

			x64_Asm_Op(BB.getCode(), X64_LOADREGS);
		}
	}
}

void jit::x64::x64_base_address_man::setBase(base_mem_type type, MBREG_TYPE& base_reg)
{
	MBREG_TYPE* new_reg = new MBREG_TYPE(base_reg);
	bases[type] = new_reg;
}

MBREG_TYPE* jit::x64::x64_base_address_man::getBase(base_mem_type type) const
{
	return bases[type];
}



MBREG_TYPE jit::x64::x64_base_address_man::load_base(CFG<IR>& cfg, MIRNode* insn)
{
	return load_base(cfg, base_manager.getType(insn));
}

std::string jit::x64::x64_base_address_man::get_mem_string(base_mem_type type)
{
	switch(type)
	{
		case packet:
			return std::string("packet");
		case info:
			return std::string("info");
		case data:
			return std::string("data");
		case invalid:
			return std::string("invalid");
	}

	return std::string();
}

MBREG_TYPE jit::x64::x64_base_address_man::load_base(CFG<x64Instruction>& cfg, base_mem_type type)
{
	MBREG_TYPE* base = base_manager.getBase(type);
	x64Instruction* insn;

	if(base == NULL)
	{
		MBREG_TYPE res(X64_NEW_VIRT_REG);
		BasicBlock<x64Instruction>* BB = cfg.getEntryBB();

		std::string comment = std::string("load base for ") + get_mem_string(type) + " mem";

		if( type == x64_base_address_man::packet){
		  insn = x64_Asm_Op_Mem_Base_To_Reg(BB->getCode(), X64_MOV, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), 0, res, x64_QWORD);
		  x64_Asm_Append_Comment(insn, comment.c_str());
		  insn = x64_Asm_Op_Mem_Base_To_Reg(BB->getCode(), X64_MOV, res, x64_offsets.ExchangeBuffer.PacketBuffer , res, x64_QWORD);
		  x64_Asm_Append_Comment(insn, "base address PKT mem in register");
		}
		if( type == x64_base_address_man::info){
		  insn = x64_Asm_Op_Mem_Base_To_Reg(BB->getCode(), X64_MOV, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), 0, res, x64_QWORD);
		  x64_Asm_Append_Comment(insn, comment.c_str());
		  insn = x64_Asm_Op_Mem_Base_To_Reg(BB->getCode(), X64_MOV, res, x64_offsets.ExchangeBuffer.InfoData, res, x64_QWORD);
		  x64_Asm_Append_Comment(insn, "base address INFO BUFFER in register");
		}
		if( type == x64_base_address_man::data){
		  assert(1 == 0 && " X64_DATA NOT IMPLEMENTED!!!");
		//insn = x64_Asm_Op_Imm_To_Reg(BB->getCode(), X64_MOV, (uint64_t)jit::Application::getApp(*BB).getMemDescriptor(jit::Application::data).Base , res, x64_DWORD);
		//x64_Asm_Append_Comment(insn, "base address DATA BUFFER in register");
		}


		base_manager.setBase(type, res);
		return res;
	}

	return *base;
}



x64_base_address_man::base_mem_type x64_base_address_man::getType(MIRNode *insn)
{
	assert(insn != NULL);

	switch(insn->getOpcode())
	{
		case PBLDS:
		case PBLDU:
		case PSLDS:
		case PSLDU:
		case PILD:
		case PBSTR:
		case PSSTR:
		case PISTR:
			return packet;

		case ISSBLD:
		case ISBLD:
		case ISSSLD:
		case ISSLD:
		case ISSILD:
		case IBSTR:
		case ISSTR:
		case IISTR:
			return info;

		case DBLDS:
		case DBLDU:
		case DSLDS:
		case DSLDU:
		case DILD:
		case DBSTR:
		case DSSTR:
		case DISTR:
			return data;
	}

	assert(1 == 0 && "invalid memory type");
	return invalid;
}

jit::x64::x64_base_address_man::x64_base_address_man()
{
	bases[0] = bases[1] = NULL;
}

void jit::x64::x64_base_address_man::reset()
{
	if(bases[0])
		delete bases[0];

	if(bases[1])
		delete bases[1];


	bases[0] = bases[1] = NULL;
}

jit::x64::x64_dim_man::x64_dim_man()
{
	dim[0] = dim[1] = NULL;
}

void jit::x64::x64_dim_man::reset()
{

	if(dim[0])
		delete dim[0];

	if(dim[1])
		delete dim[1];

	dim[0] = dim[1] = NULL;
}


MBREG_TYPE* jit::x64::x64_dim_man::getDim(dim_mem_type type) const
{
	return dim[type];
}

void jit::x64::x64_dim_man::setDim(dim_mem_type type, MBREG_TYPE& dim_reg)
{
	MBREG_TYPE* new_reg = new MBREG_TYPE(dim_reg);
	dim[type] = new_reg;
}

MBREG_TYPE jit::x64::x64_dim_man::load_dim(CFG<IR>& cfg, MIRNode* insn)
{
	return load_dim(cfg, dim_manager.getType(insn));
}

MBREG_TYPE jit::x64::x64_dim_man::load_dim(CFG<x64Instruction>& cfg, dim_mem_type type)
{
	MBREG_TYPE* dim = dim_manager.getDim(type);
	x64Instruction* insn;

	if(dim == NULL)
	{
		MBREG_TYPE res(X64_NEW_VIRT_REG);
		BasicBlock<x64Instruction>* BB = cfg.getEntryBB();

		std::string comment = std::string("load dim for ") + get_mem_string(type) + " mem";



		if( type == x64_dim_man::packet){
		insn = x64_Asm_Op_Mem_Base_To_Reg(BB->getCode(), X64_MOV, X64_MACH_REG(EXCHANGE_BUFFER_REGISTER), 0, res, x64_QWORD);
		x64_Asm_Append_Comment(insn, comment.c_str());
		insn = x64_Asm_Op_Mem_Base_To_Reg(BB->getCode(), X64_MOV, res, x64_offsets.ExchangeBuffer.PacketLen , res, x64_QWORD);
		x64_Asm_Append_Comment(insn, "Dim PKT in register");
		}
		if( type == x64_dim_man::info){
		  assert(1 == 0 && " X64_INFO NOT IMPLEMENTED!!!");
		//insn = x64_Asm_Op_Mem_Base_To_Reg(BB->getCode(), X64_MOV, X64_MACH_REG(RBP), 8, res, x64_DWORD);
		//x64_Asm_Append_Comment(insn, comment.c_str());
		//x64_Asm_Op_Mem_Base_To_Reg(BB->getCode(), X64_MOV, res, 0, res, x64_DWORD);
		//insn = x64_Asm_Op_Mem_Base_To_Reg(BB->getCode(), X64_MOV, res, x64_offsets.ExchangeBuffer.InfoLen , res, x64_DWORD);
		//x64_Asm_Append_Comment(insn, "Dim INFO BUFFER in register");
		}

		if( type == x64_dim_man::data){
		  assert(1 == 0 && " X64_DATA NOT IMPLEMENTED!!!");
		//insn = x64_Asm_Op_Imm_To_Reg(BB->getCode(), X64_MOV, (uint32_t)jit::Application::getApp(BB->getId()).getMemDescriptor(jit::Application::data).Size , res, x64_DWORD);
		//x64_Asm_Append_Comment(insn, "Dim DATA BUFFER in register");
		}


		dim_manager.setDim(type, res);
		return res;
	}

	return *dim;
}

std::string jit::x64::x64_dim_man::get_mem_string(dim_mem_type type)
{
	switch(type)
	{
		case packet:
			return std::string("packet");
		case info:
			return std::string("info");
		case data:
			return std::string("data");
		case invalid:
			return std::string("invalid");
	}

	return std::string();
}

x64_dim_man::dim_mem_type x64_dim_man::getType(MIRNode *insn)
{
	assert(insn != NULL);

	switch(insn->getOpcode())
	{
		case PBLDS:
		case PBLDU:
		case PSLDS:
		case PSLDU:
		case PILD:
		case PBSTR:
		case PSSTR:
		case PISTR:
			return packet;

		case ISSBLD:
		case ISBLD:
		case ISSSLD:
		case ISSLD:
		case ISSILD:
		case IBSTR:
		case ISSTR:
		case IISTR:
			return info;

		case DBLDS:
		case DBLDU:
		case DSLDS:
		case DSLDU:
		case DILD:
		case DBSTR:
		case DSSTR:
		case DISTR:
			return data;
	}

	assert(1 == 0 && "invalid memory type");
	return invalid;
}

x64OpndSz jit::x64::get_size_op(MIRNode *insn)
{
	assert(insn != NULL);

	switch(insn->getOpcode())
	{
		case PBLDS:
		case PBLDU:
		case PBSTR:
		case DBLDS:
		case DBLDU:
		case DBSTR:
		case ISSBLD:
		case ISBLD:
		case IBSTR:
			return x64_BYTE;

		case PSLDS:
		case PSLDU:
		case PSSTR:
		case ISSSLD:
		case ISSLD:
		case ISSTR:
		case DSLDS:
		case DSLDU:
		case DSSTR:
			return x64_WORD;

		case PILD:
		case PISTR:
		case IISTR:
		case ISSILD:
		case DILD:
		case DISTR:
			return x64_DWORD;
	}

	assert(1 == 0 && "invalid memory type");
	return x64_BYTE;
}

void jit::x64::emit_start_prof_counter(BasicBlock<IR>& BB, uint32_t stack_offset)
{
    x64_Asm_Op( BB.getCode(), X64_RDTSC);

	x64_Asm_Op_Reg_To_Mem_Base( BB.getCode(), X64_MOV, X64_MACH_REG(EAX), X64_MACH_REG(RSP), stack_offset + 0, x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Base( BB.getCode(), X64_MOV, X64_MACH_REG(EDX), X64_MACH_REG(RSP), stack_offset + 4, x64_DWORD);
}

void jit::x64::emit_stop_prof_counter(jit::BasicBlock<IR>& BB, uint32_t stack_offset)
{
#ifdef RTE_PROFILE_COUNTERS
	x64_Asm_Comment(BB.getCode(), "profiling instructions");
    //put stop in edx:eax
    x64_Asm_Op( BB.getCode(), X64_RDTSC);

	//current ticks -= start-ticks

	x64_Asm_Op_Mem_Base_To_Reg( BB.getCode(), X64_SUB, X64_MACH_REG(RSP), stack_offset + 0, X64_MACH_REG(EAX), x64_DWORD);
	x64_Asm_Op_Mem_Base_To_Reg( BB.getCode(), X64_SBB, X64_MACH_REG(RSP), stack_offset + 4, X64_MACH_REG(EDX), x64_DWORD);

	//subtract delta ticks
	nvmHandlerState *HandlerState = APPLICATION.getCurrentPEHandler()->HandlerState;
	uint64_t* addr = &HandlerState->ProfCounters->TicksDelta;

	//x64_Asm_Op_Mem_Displ_To_Reg( BB.getCode(), X64_SUB, (uint32_t)addr,       X64_MACH_REG(EAX), x64_DWORD);
	//x64_Asm_Op_Mem_Displ_To_Reg( BB.getCode(), X64_SBB, ((uint32_t)addr) + 4, X64_MACH_REG(EDX), x64_DWORD);

	//add to NumTicks
	addr = &HandlerState->ProfCounters->NumTicks;

	x64_Asm_Op_Reg_To_Mem_Displ( BB.getCode(), X64_ADD, X64_MACH_REG(EAX), (uint64_t)addr,       x64_DWORD);
	x64_Asm_Op_Reg_To_Mem_Displ( BB.getCode(), X64_ADC, X64_MACH_REG(EDX), ((uint64_t)addr) + 4, x64_DWORD);
#endif
}
