// T_NO_ARG_INST				No arguments to instruction
// T_1BYTE_ARG_INST				1 BYTE argument
// T_1_SHORT_LABEL_INST			1 BYTE (1 byte) address
// T_1WORD_ARG_INST				2 BYTES (1 word) argument
// T_1LABEL_INST				4 BYTES (1 Long) address
// T_1INT_ARG_INST				4 BYTES (1 Long) argument
// T_2INT_ARG_INST				8 BYTES (2 Long) argument
// T_1_PUSH_PORT_ARG_INST		4 BYTES (1 Long) argument
// T_1_PULL_PORT_ARG_INST		4 BYTES (1 Long) argument
// T_2_COPRO_IO_ARG_INST		8
// T_COPRO_INIT_INST			8
// T_JMP_TBL_LKUP_INST			This corresponds to a switch statement


//
//	  Canonical Name		String Name			Operand Params				Code		Consts																					"name|category|main description|possible exception|stack transition|variant description"
// --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------

// NOTE: opcodes with name="" and params=0 still need to be defined

// Load and store instructions

nvmOPCODE(PBLDS,			"spload.8",			T_NO_ARG_INST,				0x00,		OP_TYPE_NTERM|OP_LOAD|MEM_PACKET|DIM_8|SIGNED|ONE_OP|ONE_DEF,							"load|Load and store|Copy a value from a specified memory to the top of the stack. The value loaded is taken from an address popped out from the stack, so this instruction must be precedeed by a push instruction. In our architecture, the stack has only one data type (32bit), so when loading a different data type (8bit or 16bit) an appropriate conversion is needed (signed or unsigned). When loading a 32bit int no conversion is needed, regardless the sign of the value loaded|The stack is empty (i.e., no elements can be popped out from the stack); the address popped out is out of bounds of the memory segment| address --> value|Load a signed 8bit int from the packet buffer segment on the stack after conversion to a 32bit int")
nvmOPCODE(PBLDU,			"upload.8",			T_NO_ARG_INST,				0x01,		OP_TYPE_NTERM|OP_LOAD|MEM_PACKET|DIM_8|UNSIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load an unsigned 8bit int from the packet buffer segment on the stack after conversion to a 32bit int")
nvmOPCODE(PSLDS,			"spload.16",		T_NO_ARG_INST,				0x02,		OP_TYPE_NTERM|OP_LOAD|MEM_PACKET|DIM_16|SIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load a signed 16bit int from the packet memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(PSLDU,			"upload.16",		T_NO_ARG_INST,				0x03,		OP_TYPE_NTERM|OP_LOAD|MEM_PACKET|DIM_16|UNSIGNED|ONE_OP|ONE_DEF,						"load|Load and store||||Load an unsigned 16bit int from the packet memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(PILD,				"spload.32",		T_NO_ARG_INST,				0x04,		OP_TYPE_NTERM|OP_LOAD|MEM_PACKET|DIM_32|SIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load a 32bit int from the packet memory segment on the stack")
nvmOPCODE(DBLDS,			"smload.8",			T_NO_ARG_INST,				0x05,		OP_TYPE_NTERM|OP_LOAD|MEM_DATA|DIM_8|SIGNED|ONE_OP|ONE_DEF,								"load|Load and store||||Load a signed 8bit int from the data memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(DBLDU,			"umload.8",			T_NO_ARG_INST,				0x06,		OP_TYPE_NTERM|OP_LOAD|MEM_DATA|DIM_8|UNSIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load an unsigned 8bit int from the data memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(DSLDS,			"smload.16",		T_NO_ARG_INST,				0x07,		OP_TYPE_NTERM|OP_LOAD|MEM_DATA|DIM_16|SIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load a signed 16bit int from the data memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(DSLDU,			"umload.16",		T_NO_ARG_INST,				0x08,		OP_TYPE_NTERM|OP_LOAD|MEM_DATA|DIM_16|UNSIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load an unsigned 16bit int from the data memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(DILD,				"umload.32",		T_NO_ARG_INST,				0x09,		OP_TYPE_NTERM|OP_LOAD|MEM_DATA|DIM_32|UNSIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load a 32bit int from the packet data segment on the stack")
nvmOPCODE(SBLDS,			"ssload.8",			T_NO_ARG_INST,				0x46,		OP_TYPE_NTERM|OP_LOAD|MEM_SHARED|DIM_8|SIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load a signed 8bit int from the shared memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(SBLDU,			"usload.8",			T_NO_ARG_INST,				0x47,		OP_TYPE_NTERM|OP_LOAD|MEM_SHARED|DIM_8|UNSIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load an unsigned 8bit int from the packet buffer segment on the stack after conversion to a 32bit int")
nvmOPCODE(SSLDS,			"ssload.16",		T_NO_ARG_INST,				0x48,		OP_TYPE_NTERM|OP_LOAD|MEM_SHARED|DIM_16|SIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load a signed 16bit int from the shared memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(SSLDU,			"usload.16",		T_NO_ARG_INST,				0x49,		OP_TYPE_NTERM|OP_LOAD|MEM_SHARED|DIM_16|UNSIGNED|ONE_OP|ONE_DEF,						"load|Load and store||||Load an unsigned 16bit int from the shared memory segment on the stack after conversion to a 32bit int")
nvmOPCODE(SILD,				"ssload.32",		T_NO_ARG_INST,				0x4a,		OP_TYPE_NTERM|OP_LOAD|MEM_SHARED|DIM_32|SIGNED|ONE_OP|ONE_DEF,							"load|Load and store||||Load a 32bit int from the shared memory segment on the stack")
nvmOPCODE(BPLOAD_IH,		"iplen",			T_NO_ARG_INST,				0x0f,		OP_TYPE_STMT|OP_IPLEN|ONE_OP|ONE_DEF,													"iplen|Load and store|Load a byte from the packet memory, masks it with the 0x0f constant and multiplies it for 4. Can be used to calculate the lenght of an IP header|||")
nvmOPCODE(DBSTR,			"mstore.8",			T_NO_ARG_INST,				0x10,		OP_TYPE_STMT|OP_STORE|MEM_DATA|DIM_8|SIGNED|TWO_OPS|NO_DEF,								"store|Load and store|The value on the top of the stack is popped out and stored in the appropriate memory segment, at an address popped from the stack as well. Like the load instruction, when storing a 32bit int there's no difference from signed and unsigned (the value on the stack is already a 32bit int); when storing a 8bit int or a 16bit int, a conversion is needed before storing the value on the memory segment (the conversion will be different if the value has to be considered signed or unsigned).The value is transformed in the apposite format (network-byte order or host-byte order) before the store.|The stack is empty (i.e., no elements can be popped out from the stack); the address is out of bounds of the memory segment| address, value --> (none)|Store a 8bit int from the stack to data memory after conversion from a 32bit int")
nvmOPCODE(DSSTR,			"mstore.16",		T_NO_ARG_INST,				0x12,		OP_TYPE_STMT|OP_STORE|MEM_DATA|DIM_16|SIGNED|TWO_OPS|NO_DEF,							"store|Load and store||||Store a 16bit int from the stack to data memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(DISTR,			"mstore.32",		T_NO_ARG_INST,				0x14,		OP_TYPE_STMT|OP_STORE|MEM_DATA|DIM_32|SIGNED|TWO_OPS|NO_DEF,							"store|Load and store||||Store a 32bit int from the stack to data memory")
nvmOPCODE(PBSTR,			"pstore.8",			T_NO_ARG_INST,				0x15,		OP_TYPE_STMT|OP_STORE|MEM_PACKET|DIM_8|SIGNED|TWO_OPS|NO_DEF,							"store|Load and store||||Store an 8bit int from the stack to packet memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(PSSTR,			"pstore.16",		T_NO_ARG_INST,				0x18,		OP_TYPE_STMT|OP_STORE|MEM_PACKET|DIM_16|SIGNED|TWO_OPS|NO_DEF,							"store|Load and store||||Store a 16bit int from the stack to packet memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(PISTR,			"pstore.32",		T_NO_ARG_INST,				0x19,		OP_TYPE_STMT|OP_STORE|MEM_PACKET|DIM_32|SIGNED|TWO_OPS|NO_DEF,							"store|Load and store||||Store a 32bit int from the stack to packet memory")
nvmOPCODE(SBSTR,			"sstore.8",			T_NO_ARG_INST,				0x4c,		OP_TYPE_STMT|OP_STORE|MEM_SHARED|DIM_8|SIGNED|TWO_OPS|NO_DEF,							"store|Load and store||||Store an 8bit int from the stack to shared memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(SSSTR,			"sstore.16",		T_NO_ARG_INST,				0x4d,		OP_TYPE_STMT|OP_STORE|MEM_SHARED|DIM_16|SIGNED|TWO_OPS|NO_DEF,							"store|Load and store||||Store a 16bit int from the stack to shared memory eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(SISTR,			"sstore.32",		T_NO_ARG_INST,				0x4f,		OP_TYPE_STMT|OP_STORE|MEM_SHARED|DIM_32|SIGNED|TWO_OPS|NO_DEF,							"store|Load and store||||Store a 32bit int from the stack to shared memory")


// Info field manipulation

nvmOPCODE(IBSTR,			"istore.8",			T_NO_ARG_INST,				0xf0,		OP_TYPE_STMT|OP_STORE|MEM_INFO|DIM_8|UNSIGNED|TWO_OPS|NO_DEF,							"store|Info field manipulation||||Store an 8bit int from the stack to info field eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(ISSTR,			"istore.16",		T_NO_ARG_INST,				0xf1,		OP_TYPE_STMT|OP_STORE|MEM_INFO|DIM_16|UNSIGNED|TWO_OPS|NO_DEF,							"store|Info field manipulation||||Store a 16bit int from the stack to info field eventually truncating it from 32bit int (least significant bits are stored)")
nvmOPCODE(IISTR,			"istore.32",		T_NO_ARG_INST,				0xf2,		OP_TYPE_STMT|OP_STORE|MEM_INFO|DIM_32|UNSIGNED|TWO_OPS|NO_DEF,							"store|Info field manipulation||||Store a 32bit int from the stack to info field")
nvmOPCODE(ISBLD,			"uiload.8",			T_NO_ARG_INST,				0xf3,		OP_TYPE_NTERM|OP_LOAD|MEM_INFO|DIM_8|UNSIGNED|ONE_OP|ONE_DEF,							"load|Info field manipulation||||Load an unsigned 8bit int from the info field on the stack after conversion to a 32bit int")
nvmOPCODE(ISSLD,			"uiload.16",		T_NO_ARG_INST,				0xf4,		OP_TYPE_NTERM|OP_LOAD|MEM_INFO|DIM_16|UNSIGNED|ONE_OP|ONE_DEF,							"load|Info field manipulation||||Load an unsigned 16bit int from the info field on the stack after conversion to a 32bit int")
nvmOPCODE(ISSBLD,			"siload.8",			T_NO_ARG_INST,				0xf5,		OP_TYPE_NTERM|OP_LOAD|MEM_INFO|DIM_8|SIGNED|ONE_OP|ONE_DEF,								"load|Info field manipulation||||Load a signed 8bit int from the info field on the stack after conversion to a 32bit int")
nvmOPCODE(ISSSLD,			"siload.16",		T_NO_ARG_INST,				0xf6,		OP_TYPE_NTERM|OP_LOAD|MEM_INFO|DIM_16|SIGNED|ONE_OP|ONE_DEF,							"load|Info field manipulation||||Load a signed 16bit int from the info field on the stack after conversion to a 32bit int")
nvmOPCODE(ISSILD,			"siload.32",		T_NO_ARG_INST,				0xf7,		OP_TYPE_NTERM|OP_LOAD|MEM_INFO|DIM_32|SIGNED|ONE_OP|ONE_DEF,							"load|Info field manipulation||||Load a signed 32bit int from the info field on the stack")



// Arithmetic instructions

nvmOPCODE(ADD,				"add",				T_NO_ARG_INST,				0x20,		OP_TYPE_NTERM|OP_ARITH|ARITH_ADD|UNSIGNED|TWO_OPS|ONE_DEF,								"add|Arithmetic and logic|Addition of the top two items of the stack|The stack is empty (i.e., no elements can be popped out from the stack); Overflow or underflow|value1, value2 --> result|Addition of the two top items of the stack without overflow control")
nvmOPCODE(ADDSOV,			"add.s",			T_NO_ARG_INST,				0x21,		OP_TYPE_NTERM|OP_ARITH|ARITH_ADD|SIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"add|Arithmetic and logic||||Addition of the two top items of the stack considered as signed 32bit int with overflow control")
nvmOPCODE(ADDUOV,			"add.u",			T_NO_ARG_INST,				0x22,		OP_TYPE_NTERM|OP_ARITH|ARITH_ADD|UNSIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"add|Arithmetic and logic||||Addition of the two top items of the stack considered as unsigned 32bit int with overflow control")
nvmOPCODE(SUB,				"sub",				T_NO_ARG_INST,				0x23,		OP_TYPE_NTERM|OP_ARITH|ARITH_SUB|UNSIGNED|TWO_OPS|ONE_DEF,								"sub|Arithmetic and logic|Subtraction of the first value popped from the stack to the second value|The stack is empty (i.e., no elements can be popped out from the stack); Overflow or underflow|value1, value2 --> result|Subtraction the first value on the stack to the second one without overflow control")
nvmOPCODE(SUBSOV,			"sub.s",			T_NO_ARG_INST,				0x24,		OP_TYPE_NTERM|OP_ARITH|ARITH_SUB|SIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"sub|Arithmetic and logic||||Subtraction the first value on the stack to the second one considered as signed 32bit with overflow control")
nvmOPCODE(SUBUOV,			"sub.u",			T_NO_ARG_INST,				0x25,		OP_TYPE_NTERM|OP_ARITH|ARITH_SUB|UNSIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"sub|Arithmetic and logic||||Subtraction the first value on the stack to the second one considered as unsigned 32bit with overflow control")
nvmOPCODE(IMUL,				"mul",				T_NO_ARG_INST,				0x26,		OP_TYPE_NTERM|OP_ARITH|ARITH_MUL|UNSIGNED|TWO_OPS|ONE_DEF,								"mul|Arithmetic and logic|Multiplication of the first two values on the stack |The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 --> result|Multiplication of the first two values on the stack without overflow control")
nvmOPCODE(IMULSOV,			"muls.ovf",			T_NO_ARG_INST,				0x27,		OP_TYPE_NTERM|OP_ARITH|ARITH_MUL|SIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"mul|Arithmetic and logic||||Multiplication of the first two values on the stack considered as signed 32bit with overflow control")
nvmOPCODE(IMULUOV,			"mul.ovf",			T_NO_ARG_INST,				0x28,		OP_TYPE_NTERM|OP_ARITH|ARITH_MUL|UNSIGNED|OVERFLOW|TWO_OPS|ONE_DEF,						"mul|Arithmetic and logic||||Multiplication of the first two values on the stack considered as unsigned 32bit with overflow control")

nvmOPCODE(MOD,				"mod",				T_NO_ARG_INST,				0x3f,		OP_TYPE_NTERM|OP_ARITH|ARITH_MOD|TWO_OPS|ONE_DEF,										"mod|Arithmetic and logic|Modulus of the first two values on the stack considered as unsigned 32bit|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 --> result|Modulus of the first two values on the stack without overflow control")

nvmOPCODE(NEG,				"neg",				T_NO_ARG_INST,				0x29,		OP_TYPE_NTERM|OP_ARITH|ARITH_NEG|ONE_OP|ONE_DEF,										"neg|Arithmetic and logic|2's complement of the first value on the stack|none|value --> result|The operand value is taken from the first element of the stack and the result is returned over it")
nvmOPCODE(OR,				"or",				T_NO_ARG_INST,				0x2a,		OP_TYPE_NTERM|OP_ARITH|ARITH_OR|TWO_OPS|ONE_DEF,										"or|Arithmetic and logic|Bitwise OR of the first two values on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 --> result|Bitwise OR of the first two values of the stack; the result is pushed on the stack")
nvmOPCODE(AND,				"and",				T_NO_ARG_INST,				0x2b,		OP_TYPE_NTERM|OP_ARITH|ARITH_AND|TWO_OPS|ONE_DEF,										"and|Arithmetic and logic|Bitwise AND of the first two values on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 --> result|Bitwise AND of the first two values of the stack; the result is pushed on the stack")
nvmOPCODE(XOR,				"xor",				T_NO_ARG_INST,				0x2c,		OP_TYPE_NTERM|OP_ARITH|ARITH_XOR|ONE_OP|ONE_DEF,										"xor|Arithmetic and logic|Bitwise XOR of the first two values on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2 --> result|Bitwise XOR of the first two values of the stack; the result is pushed on the stack")
nvmOPCODE(NOT,				"not",				T_NO_ARG_INST,				0x3e,		OP_TYPE_NTERM|OP_ARITH|ARITH_NOT|ONE_OP|ONE_DEF,										"not|Arithmetic and logic|Bitwise NOT of the first value on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|value --> result|Uniwise NOT of the first value of the stack; the result is pushed on the stack")
nvmOPCODE(IINC_1,			"inc1",				T_NO_ARG_INST,				0x2d,		OP_TYPE_NTERM|OP_ARITH|ARITH_IINC_1|ONE_OP|ONE_DEF,										"inc|Arithmetic and logic|Increment of the value of an element on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|(none)|Increment the 1st element of the stack")
nvmOPCODE(IINC_2,			"inc2",				T_NO_ARG_INST,				0x2e,		OP_TYPE_NTERM|OP_ARITH|ARITH_IINC_2|ONE_OP|ONE_DEF,										"inc|Arithmetic and logic||||Increment the 2nd element of the stack")
nvmOPCODE(IINC_3,			"inc3",				T_NO_ARG_INST,				0x2f,		OP_TYPE_NTERM|OP_ARITH|ARITH_IINC_3|ONE_OP|ONE_DEF,										"inc|Arithmetic and logic||||Increment the 3rd element of the stack")
nvmOPCODE(IINC_4,			"inc4",				T_NO_ARG_INST,				0xea,		OP_TYPE_NTERM|OP_ARITH|ARITH_IINC_4|ONE_OP|ONE_DEF,										"inc|Arithmetic and logic||||Increment the 4th element of the stack")
nvmOPCODE(IDEC_1,			"dec1",				T_NO_ARG_INST,				0xeb,		OP_TYPE_NTERM|OP_ARITH|ARITH_IDEC_1|ONE_OP|ONE_DEF,										"dec|Arithmetic and logic|Decrement of the value of an element on the stack|The stack is empty (i.e., no elements can be popped out from the stack)|(none)|Deccrement the 1st element of the stack")
nvmOPCODE(IDEC_2,			"dec2",				T_NO_ARG_INST,				0xec,		OP_TYPE_NTERM|OP_ARITH|ARITH_IDEC_2|ONE_OP|ONE_DEF,										"dec|Arithmetic and logic||||Decrement the 2nd element of the stack")
nvmOPCODE(IDEC_3,			"dec3",				T_NO_ARG_INST,				0xed,		OP_TYPE_NTERM|OP_ARITH|ARITH_IDEC_3|ONE_OP|ONE_DEF,										"dec|Arithmetic and logic||||Decrement the 3rd element of the stack")
nvmOPCODE(IDEC_4,			"dec4",				T_NO_ARG_INST,				0x30,		OP_TYPE_NTERM|OP_ARITH|ARITH_IDEC_4|ONE_OP|ONE_DEF,										"dec|Arithmetic and logic||||Decrement the 4th element of the stack")
nvmOPCODE(SHL,				"shl",				T_NO_ARG_INST,				0x31,		OP_TYPE_NTERM|OP_ARITH|ARITH_SHL|TWO_OPS|ONE_DEF,										"shl|Arithmetic and logic|Arithmetical left shift|none|value1, value2 --> result|The vacated right bits are set to 0. This instruction performs the moltiplication of value 2 by 2^value1 for signed integers. The result is unpredicted if the right operand is greater than or equal to the width in bits of the promoted left operand.")
nvmOPCODE(SHR,				"shr",				T_NO_ARG_INST,				0x32,		OP_TYPE_NTERM|OP_ARITH|ARITH_SHR|TWO_OPS|ONE_DEF,										"shr|Arithmetic and logic|Arithmetical right shift of the second element on the stack of a number of position popped from the top of the stack|none|value1, value2 --> result|The vacated left bits are filled with copies of the sign bit. This instruction performs the division of value2 by 2^value1 for signed integers")
nvmOPCODE(USHR,				"ushr",				T_NO_ARG_INST,				0x34,		OP_TYPE_NTERM|OP_ARITH|ARITH_USHR|TWO_OPS|ONE_DEF,										"ushr|Arithmetic and logic|Logical right shift of the second element on the stack of a number of position popped from the top of the stack|none|value1, value2 --> result|The vacated left bits are set to 0. This instruction performs the division of value2 by 2^value1 for unsigned integers")
nvmOPCODE(IRND,				"rnd",				T_NO_ARG_INST,				0x35,		OP_TYPE_NTERM|OP_ARITH|ARITH_IRND|NO_OPS|ONE_DEF,										"rnd|Arithmetic and logic|Puts a random integer on the stack|none|(none) --> result|")
nvmOPCODE(CMP,				"cmp",				T_NO_ARG_INST,				0x36,		OP_TYPE_NTERM|OP_ARITH|ARITH_CMP|TWO_OPS|ONE_DEF,										"cmp|Arithmetic and logic|A comparison is done between the first two elements on the stack. If necessary, the values are previously masked by a value popped out from the stack as well. If value1 is equal to value2, the constant 0 will be pushed on the stack; if value1 is greater than value2, the constant 1 will be pushed on the stack; if value1 is lower than value2, the constant -1 will be pushed on the stack.|The stack is empty (i.e., no elements can be popped out from the stack)|value1, value2, (mask) --> result|Compares the first two items on the stack")
nvmOPCODE(MCMP,				"mcmp",				T_NO_ARG_INST,				0x37,		OP_TYPE_NTERM|OP_ARITH|ARITH_MCMP|TWO_OPS|ONE_DEF,										"cmp|Arithmetic and logic||||Performs a masked comparison between the first two elements n the stack. The mask is on the stack as well.")
nvmOPCODE(JCMPEQ,			"jcmp.eq",			T_1LABEL_INST,				0x38,		OP_TYPE_STMT|OP_JUMP|CND_EQ|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,				"jcmp|Flow control|Comparison between the first two items of the stack. If the test went right, branch will occur. The branch offset can be positive or negative. A value of 'N' means a jmp to an offset equal to 'current+5+N' (where 5 is due to the length of the current instruction, 1 for the opcode, 4 for the offset).|The stack is empty (i.e., no elements can be popped out from the stack); the branch is out of bounds of the code memory segment|value1, value2 --> (none) |Branch if the first element on the stack is equal to the second one")
nvmOPCODE(JCMPNEQ,			"jcmp.neq",			T_1LABEL_INST,				0x39,		OP_TYPE_STMT|OP_JUMP|CND_NEQ|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,			"jcmp|Flow control||||Branch if the first element on the stack is not equal to the second one")
nvmOPCODE(JCMPG,			"jcmp.g",			T_1LABEL_INST,				0x3a,		OP_TYPE_STMT|OP_JUMP|CND_G|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,				"jcmp|Flow control||||Branch if the first element on the stack is greater than the second one")
nvmOPCODE(JCMPGE,			"jcmp.ge",			T_1LABEL_INST,				0x3b,		OP_TYPE_STMT|OP_JUMP|CND_GE|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,				"jcmp|Flow control||||Branch if the first element on the stack is greater than or equal to the second one")
nvmOPCODE(JCMPL,			"jcmp.l",			T_1LABEL_INST,				0x3c,		OP_TYPE_STMT|OP_JUMP|CND_L|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,				"jcmp|Flow control||||Branch if the first element on the stack is lower than the second one")
nvmOPCODE(JCMPLE,			"jcmp.le",			T_1LABEL_INST,				0x3d,		OP_TYPE_STMT|OP_JUMP|CND_LE|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,				"jcmp|Flow control||||Branch if the first element on the stack is lower than or equal to the second one")
nvmOPCODE(JCMPG_S,			"jcmp.gts",			T_1LABEL_INST,				0xc0,		OP_TYPE_STMT|OP_JUMP|CND_G|SIGNED|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,		"jcmp|Flow control||||Branch if the first element on the stack is greater than the second one, considering both element as signed int")
nvmOPCODE(JCMPGE_S,			"jcmp.ges",			T_1LABEL_INST,				0xc1,		OP_TYPE_STMT|OP_JUMP|CND_GE|SIGNED|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,		"jcmp|Flow control||||Branch if the first element on the stack is equal to or greater than the second one, considering both element as signed int")
nvmOPCODE(JCMPL_S,			"jcmp.lts",			T_1LABEL_INST,				0xc2,		OP_TYPE_STMT|OP_JUMP|CND_L|SIGNED|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,		"jcmp|Flow control||||Branch if the first element on the stack is lower than the second one, considering both element as signed int")
nvmOPCODE(JCMPLE_S,			"jcmp.les",			T_1LABEL_INST,				0xc3,		OP_TYPE_STMT|OP_JUMP|CND_LE|SIGNED|JMPOPS_STACK|TWO_OPS|NO_DEF|JMPTGT_TWO_TARGETS,		"jcmp|Flow control||||Branch if the first element on the stack is equal to or lower than the second one, considering both element as signed int")
nvmOPCODE(CMP_S,			"cmp.s",			T_1LABEL_INST,				0xc4,		OP_TYPE_NTERM|OP_ARITH|ARITH_CMP|SIGNED|TWO_OPS|ONE_DEF,								"cmp|Arithmetic and logic||||Masked comparison between the two top items of the stack")
nvmOPCODE(ROTL,				"rol",				T_NO_ARG_INST,				0x44,		OP_TYPE_NTERM|OP_ARITH|ARITH_ROTL|TWO_OPS|ONE_DEF,										"rol|Arithmetic and logic|Rotate to the left the bits of the second element from the top of the stack of a number of bits specified on the top of the stack |none|value1, value2 --> result|Value2 is popped from the stack and rotated of a number of bits taken from value 1. The result is pushed on the stack")
nvmOPCODE(ROTR,				"ror",				T_NO_ARG_INST,				0x45,		OP_TYPE_NTERM|OP_ARITH|ARITH_ROTR|TWO_OPS|ONE_DEF,										"ror|Arithmetic and logic|Rotate to the right the bits of the second element from the top of the stack of a number of bits specified on the top of the stack|none|value1, value2 --> result|Value2 is popped from the stack and rotated of a number of bits taken from value 1. The result is pushed on the stack")

// Stack management instructions (check PUSH2, DUP, SWAP, IESWAP)

nvmOPCODE(PUSH,				"push",				T_1INT_ARG_INST,			0x50,		OP_TYPE_NTERM|OP_STACK|STK_PUSH|NO_OPS|ONE_DEF,											"push|Stack management|Push a constant value on the stack|The stack is full (No elements can be pushed on the stack)|(none) value|Push a constant value on the stack")
nvmOPCODE(PUSH2,			"push2",			T_2INT_ARG_INST,			0x51,		OP_TYPE_NTERM|OP_STACK|STK_PUSH2|TWO_OPS|ONE_DEF,										"push2|Stack management|Push two constant values on the stack|The stack is full (No elements can be pushed on the stack)|(none) value, value|Push two constant values on the stack")
nvmOPCODE(POP,				"pop",				T_NO_ARG_INST,				0x52,		OP_TYPE_NTERM|OP_STACK|STK_POP|NO_OPS|NO_DEF,											"pop|Stack management|Deletion of the first value(s) of the stack.|The stack is empty (i.e., no elements can be popped out from the stack)| value --> (none) |Remove the top of the stack")
nvmOPCODE(POP_I,			"popi",				T_1BYTE_ARG_INST,			0x53,		OP_TYPE_NTERM|OP_STACK|STK_POP_I|NO_OPS|NO_DEF,											"pop|Stack management||||Deletes the first i values of the stack, where i is the paramenter of the instruction")
nvmOPCODE(CONST_1,			"push_1",			T_NO_ARG_INST,				0x54,		OP_TYPE_NTERM|OP_STACK|STK_CONST_1|NO_OPS|ONE_DEF,										"push|Stack management||||Push the constant 1 on the stack")
nvmOPCODE(CONST_2,			"push_2",			T_NO_ARG_INST,				0x55,		OP_TYPE_NTERM|OP_STACK|STK_CONST_2|NO_OPS|ONE_DEF,										"push|Stack management||||Push the constant 2 on the stack")
nvmOPCODE(CONST_0,			"push_0",			T_NO_ARG_INST,				0x56,		OP_TYPE_NTERM|OP_STACK|STK_CONST_0|NO_OPS|ONE_DEF,										"push|Stack management||||Push the constant 0 on the stack")
nvmOPCODE(CONST__1,			"push__1",			T_NO_ARG_INST,				0x57,		OP_TYPE_NTERM|OP_STACK|STK_CONST__1|NO_OPS|ONE_DEF,										"push|Stack management||||Push the constant -1 on the stack")
nvmOPCODE(TSTAMP_S,			"tstamp_s",			T_NO_ARG_INST,				0x58,		OP_TYPE_NTERM|OP_STACK|STK_TSTAMP|NO_OPS|ONE_DEF,										"tstamp_s|Stack management|This instruction puts on the stack the current timestamp in the Unix format (nanoseconds since the january 1st 1970). A value is returned by this instruction, the current time in seconds|none|(none) value1|value1 contains the number of seconds")
nvmOPCODE(TSTAMP_US,		"tstamp_us",		T_NO_ARG_INST,				0x59,		OP_TYPE_NTERM|OP_STACK|STK_TSTAMP|NO_OPS|ONE_DEF,										"tstamp|Stack management|This instruction puts on the stack the current timestamp in the Unix format (nanoseconds since the january 1st 1970). A value is returned by this instruction, the number of nanoseconds of the current time|none|(none) value1|value1 contains the number of nanoseconds of the current timestamp")
nvmOPCODE(DUP,				"dup",				T_NO_ARG_INST,				0x5a,		OP_TYPE_NTERM|OP_STACK|STK_DUP|ONE_OP|ONE_DEF,											"dup|Stack management|Duplicate the top operand stack value|The stack is full (No more elements can be pushed on the stack)|value --> value, value|")
nvmOPCODE(SWAP,				"swap",				T_NO_ARG_INST,				0x5c,		OP_TYPE_NTERM|OP_STACK|STK_SWAP|TWO_OPS|ONE_DEF,										"swap|Stack management|Exchange the top two elements of the stack|none?|value1, value2 --> value2, value1|")
nvmOPCODE(IESWAP,			"ieswap",			T_NO_ARG_INST,				0x5d,		OP_TYPE_NTERM|OP_STACK|STK_IESWAP|TWO_OPS|ONE_DEF,										"ieswap|Stack management|Exchange the mode between little endian and big endian for the element on the top of the stack|none|value --> result|value:abcd, where a,b,c and d are 8 bits longs -> result:badc")
nvmOPCODE(SLEEP,			"sleep",			T_NO_ARG_INST,				0xd6,		OP_TYPE_NTERM|OP_STACK|STK_SLEEP|ONE_OP|NO_DEF,											"sleep|Stack management|Sleep for a time specified on the stack||value --> (none)|Sleep for a time specified on the stack")
nvmOPCODE(PBL,				"pbl",				T_NO_ARG_INST,				0xe0,		OP_TYPE_NTERM|OP_STACK|STK_PBL|NO_OPS|ONE_DEF,											"pbl|Stack management|Returns the packet buffer length on the stack||(none)-->result|Returns the packet buffer length on the stack")

// Flow control instructions (check SWITCH)

nvmOPCODE(JEQ,				"j.eq",				T_1LABEL_INST,				0x60,		OP_TYPE_STMT|OP_JUMP|JMP_JUMP|CND_EQ|JMPOPS_0|ONE_OP|JMPTGT_TWO_TARGETS|NO_DEF,			"j|Flow control|Comparison between the first item on the top of the stack and 0. If test is satisfied, branch will occur. The branch offset can be positive or negative|The stack is empty (i.e., no elements can be popped out from the stack); the branch is out of bounds of the code memory segment| value --> (none)|Branch if the top of the stack is equal to 0")
nvmOPCODE(JNE,				"j.ne",				T_1LABEL_INST,				0x61,		OP_TYPE_STMT|OP_JUMP|JMP_JUMP|CND_NEQ|JMPOPS_0|ONE_OP|JMPTGT_TWO_TARGETS|NO_DEF,		"j|Flow control||||Branch if the top of the stack is not equal to 0")
nvmOPCODE(JUMP,				"jump",				T_1_SHORT_LABEL_INST,		0x67,		OP_TYPE_STMT|OP_JUMP|JMP_JUMP|NO_OPS|NO_DEF|JMPTGT_ONE_TARGET,							"jump|Flow control|Unconditional branch|The branch is out of bounds of the code memory segment| (none) |Unconditional branch")
nvmOPCODE(JUMPW,			"jump.w",			T_1LABEL_INST,				0x68,		OP_TYPE_STMT|OP_JUMP|JMP_JUMP|WIDE|NO_OPS|NO_DEF|JMPTGT_ONE_TARGET,						"jump|Flow control||||Unconditional branch (wide index)")
nvmOPCODE(SWITCH,			"switch",			T_JMP_TBL_LKUP_INST,		0x6f,		OP_TYPE_STMT|OP_JUMP|JMP_SWITCH|JMPTGT_SWITCH|ONE_OP,									"switch|Flow control||||Branch at an offset depending by element on the top of the stack")
nvmOPCODE(CALL,				"call",				T_1LABEL_INST,				0x69,		OP_TYPE_STMT|OP_JUMP|JMP_CALL|ONE_OP|NO_DEF|JMPTGT_ONE_TARGET,							"call|Flow control|Call a subroutine. Some parameters can be pushed on the stack before the instruction, they are used as parameters for the subroutine, the parameters are popped from the procedure and the return value result is pushed on the stack|none| (value1), (value 2), (...), (value n) --> (result)|Call a subroutine")
nvmOPCODE(CALLW,			"call.w",			T_1LABEL_INST,				0x6a,		OP_TYPE_STMT|OP_JUMP|JMP_CALL|WIDE|ONE_OP|NO_DEF|JMPTGT_ONE_TARGET,						"call|Flow control||||Call a subroutine (wide index)")
nvmOPCODE(RET,				"ret",				T_NO_ARG_INST,				0x6b,		OP_TYPE_STMT|OP_JUMP|JMP_RET|NO_OPS|NO_DEF|JMPTGT_NO_TARGETS,							"ret|Flow control|Returns from a subroutine or from a section|none|(none)|No elements are pushed on or popped from the stack")


//field comparison branch instructions
nvmOPCODE(JFLDEQ,			"jfield.eq",		T_1LABEL_INST,				0x70,		OP_TYPE_STMT|OP_PTNMTC|PTNMTC_JFLD|CND_EQ|TWO_OPS|NO_DEF,								"field|Pattern matching|Comparison between two fields in the packet buffer. If the test succeeds, a branch will occur. The argument is the label where to jump if the test succeeds|The stack is empty (i.e., no elements can be popped out from the stack); the branch is out of bounds of the code memory segment|len, offs_field2, offs_field1 --> (none) |Compare two fields at different offsets in the packet memory, the offsets and the length are on the top of the stack. Branch if they are equal")
nvmOPCODE(JFLDNEQ,			"jfield.ne",		T_1LABEL_INST,				0x71,		OP_TYPE_STMT|OP_PTNMTC|PTNMTC_JFLD|CND_NE|TWO_OPS|NO_DEF,								"field|Pattern matching||||Compare two fields at different offsets in the packet memory, the offsets and the length are on the top of the stack. Branch if they are not equal")
nvmOPCODE(JFLDLT,			"jfield.lt",		T_1LABEL_INST,				0x72,		OP_TYPE_STMT|OP_PTNMTC|PTNMTC_JFLD|CND_L|TWO_OPS|NO_DEF,								"field|Pattern matching||||Compare two fields at different offsets in the packet memory, the offsets and the length are on the top of the stack. Branch if the first is lexicographically less than the second")
nvmOPCODE(JFLDGT,			"jfield.gt",		T_1LABEL_INST,				0x73,		OP_TYPE_STMT|OP_PTNMTC|PTNMTC_JFLD|CND_G|TWO_OPS|NO_DEF,								"field|Pattern matching||||Compare two fields at different offsets in the packet memory, the offsets and the length are on the top of the stack. Branch if the first is lexicographically greater than the second")

//packet scan instructions
nvmOPCODE(PSCANB,			"pscan.8",			T_NO_ARG_INST,				0x74,		OP_TYPE_NTERM|OP_PTNMTC|PTNMTC_PSCAN|TWO_OPS|ONE_DEF,									"pscan|Packet Scan|Scan the packet buffer starting from a specific offset and search for the first occurrence of a specific value. If a match is found a new offset is returned, otherwise the value 0xFFFFFFFF is returned. Note: the integer value is converted in network byte order before starting the search|The stack is empty (i.e., no elements can be popped out from the stack)|offset, value --> offset |Scan the packet buffer starting from a specific offset and search for the first occurrence of a specific byte value. If a match is found a new offset is returned, otherwise the value 0xFFFFFFFF is returned")
nvmOPCODE(PSCANW,			"pscan.16",			T_NO_ARG_INST,				0x75,		OP_TYPE_NTERM|OP_PTNMTC|PTNMTC_PSCAN|TWO_OPS|ONE_DEF,									"pscan|Packet Scan||||Scan the packet buffer starting from a specific offset and search for the first occurrence of a specific word value. If a match is found a new offset is returned, otherwise the value 0xFFFFFFFF is returned")
nvmOPCODE(PSCANDW,			"pscan.32",			T_NO_ARG_INST,				0x76,		OP_TYPE_NTERM|OP_PTNMTC|PTNMTC_PSCAN|TWO_OPS|ONE_DEF,									"pscan|Packet Scan||||Scan the packet buffer starting from a specific offset and search for the first occurrence of a specific dword value. If a match is found a new offset is returned, otherwise the value 0xFFFFFFFF is returned")

// Packet and data transfer instructions (check DPMCPY...)

nvmOPCODE(SNDPKT,			"pkt.send",			T_1_PUSH_PORT_ARG_INST,		0xa4,		OP_TYPE_STMT|OP_PKT|PKT_SNDPKT|NO_OPS|NO_DEF,											"pushpkt|Packet and data transfer||||Push a packet to a push port ")
nvmOPCODE(DSNDPKT,			"pkt.senddup",		T_1_PUSH_PORT_ARG_INST,		0xb1,		OP_TYPE_STMT|OP_PKT|PKT_DSNDPKT|ONE_OP|NO_DEF,											"pushpkt|Packet and data transfer||||Push a copy of the packet to a push port ")
nvmOPCODE(RCVPKT,			"pkt.receive",		T_1_PULL_PORT_ARG_INST,		0xa5,		OP_TYPE_STMT|OP_PKT|PKT_RCVPKT|ONE_OP|NO_DEF,											"pullpkt|Packet and data transfer||||Pull a packet from a pull port")
nvmOPCODE(DPMCPY,			"dpcopy",			T_NO_ARG_INST,				0xa7,		OP_TYPE_STMT|OP_PKT|PKT_DPMCPY|NO_DEF,													"copy|Packet and data transfer|Copy a memory buffer from one memory to another. Value1, value2, value3 must be pushed on the stack before the execution of the instruction. Value1 must contain a valid offset inside data memory, value2 must contain a valid offset inside data memory, value3 must contain the length of the buffer that must be copied inside packet buffer. All the three elements are popped from the stack after the instruction|The stack is full (No elements can be pushed); the address is out of source memory segment; the address is out of destination memory segment| value3, value2, value1 --> (none) |Copy a memory buffer from data memory to packet buffer")
nvmOPCODE(PDMCPY,			"pdcopy",			T_NO_ARG_INST,				0xa8,		OP_TYPE_STMT|OP_PKT|PKT_PDMCPY|NO_DEF,													"copy|Packet and data transfer||||Copy a memory buffer from packet buffer to data memory")
nvmOPCODE(DSMCPY,			"dscopy",			T_NO_ARG_INST,				0xa9,		OP_TYPE_STMT|OP_PKT|PKT_DSMCPY|NO_DEF,													"copy|Packet and data transfer||||Copy a memory buffer from data memory to shared memory")
nvmOPCODE(SDMCPY,			"sdcopy",			T_NO_ARG_INST,				0xaa,		OP_TYPE_STMT|OP_PKT|PKT_SDMCPY|NO_DEF,													"copy|Packet and data transfer||||Copy a memory buffer from shared memory to data memory")
nvmOPCODE(SPMCPY,			"spcopy",			T_NO_ARG_INST,				0xab,		OP_TYPE_STMT|OP_PKT|PKT_SPMCPY|NO_DEF,													"copy|Packet and data transfer||||Copy a memory buffer from shared memory to packet buffer")
nvmOPCODE(PSMCPY,			"pscopy",			T_NO_ARG_INST,				0xac,		OP_TYPE_STMT|OP_PKT|PKT_PSMCPY|NO_DEF,													"copy|Packet and data transfer||||Copy a memory buffer from packet buffer to shared memory")
nvmOPCODE(IPMCPY,			"ipcopy",			T_NO_ARG_INST,				0xbd,		OP_TYPE_STMT|OP_PKT|PKT_PIMCPY|NO_DEF,													"copy|Packet and data transfer||||Copy a memory buffer from initialised data to packet buffer")

nvmOPCODE(CRTEXBUF,			"exbuf.create",		T_NO_ARG_INST,				0xad,		OP_TYPE_STMT|OP_PKT|PKT_CRTEXBUF|ONE_OP|NO_DEF,											"crtpkt|Packet and data transfer|Create an exchange buffer|The stack is empty (i.e., no elements can be popped out from the stack)| value ---> (none)| Create an Exchange Buffer whose size is passed through the stack")
nvmOPCODE(DELEXBUF,			"exbuf.delete",		T_NO_ARG_INST,				0xae,		OP_TYPE_STMT|OP_PKT|PKT_DELEXBUF|ONE_OP|NO_DEF,											"delpkt|Packet and data transfer|Delete an exchange buffer|none| (none) |Deletes the current exchange buffer")


// Control processing instructions

//!! nvmOPCODE(SCHTIMER,	,					,							0xaf,																								"Schedules a timer event that will asynchronously activate the current NetVM instance")

// Initialization instructions

// This next opcode has been removed
//nvmOPCODE(SDMSIZE,		"set.mem",			T_1INT_ARG_INST,			0xb0,		OP_TYPE_STMT|OP_INIT|INIT_SDMSIZE,														"set|Initialization|The size is passed by as a parameter (the parameter is a 8bit int). If size == 0 no memory is required. If size == -1 all physical memory available is required.|Failure in the memory allocation (if malloc returns a NULL pointer)| (none) |Set the size of the data memory")
nvmOPCODE(SSMSIZE,			"set.share",		T_1INT_ARG_INST,			0xb5,		OP_TYPE_STMT|OP_INIT|INIT_SSMSIZE,														"set|Initialization|The size is passed by as a parameter (the parameter is a 8bit int). If size == 0 no memory is required. If size == -1 all physical memory available is required.|Failure in the memory allocation (if malloc returns a NULL pointer)| (none) |Set the size of the shared memory")
nvmOPCODE(LOADE,			"loade",			T_1INT_ARG_INST,			0xb6,		OP_TYPE_NTERM|OP_INIT|INIT_LOADE,														"loade|Initialization|Load an exception table entry on the stack. The index of the entry to push on the stack is passed by as a parameter|The stack is not allocated; the stack is full (no elements can be pushed on the stack).|... --> ... - entry|")
nvmOPCODE(STOREE,			"storee",			T_1INT_ARG_INST,			0xb7,		OP_TYPE_STMT|OP_INIT|INIT_STOREE,														"storee|Initialization|Store the top of the stack to an exception table entry. The parameter is the index in the Exception Table where to store the entry popped out from the stack|The stack is not allocated; the stack is empty (i.e., no elements can be popped out from the stack)|... - entry --> ...|")
//!! nvmOPCODE(LOADV,		,					,							0xb8,																								"Load a VNIC table entry on the stack")
//!! nvmOPCODE(SPKTOFF,	,					,								0xb9,																								"Set the offset in the packet memory at which an incoming packet will be put")

// Miscellaneous nvmOPCODEs

nvmOPCODE(NOP,				"nop",				T_NO_ARG_INST,				0xd7,		OP_TYPE_STMT|OP_MISC|MISC_NOP,															"nop|Miscellaneous|Performs no operations|none| (none) |No operation")
nvmOPCODE(BRKPOINT,			"break",			T_NO_ARG_INST,				0xd8,		OP_TYPE_STMT|OP_MISC|MISC_BRKPOINT,														"break|Miscellaneous||||Used for debugging purposes")
nvmOPCODE(EXIT,				"exit",				T_1INT_ARG_INST,			0xff,		OP_TYPE_STMT|OP_MISC|MISC_EXIT,															"exit|Miscellaneous|Exit from the current context reporting en error message|none|N/A|No elements are pushed on or popped from the stack")
nvmOPCODE(INFOCLR,			"info.clr",			T_NO_ARG_INST,				0xb2,		OP_TYPE_STMT|OP_MISC,																	"set|Miscellaneous|Fills the info memory with 0s|none| (none) |Fills the info memory with 0s")
// MACROINSTRUCTIONS

//Bit manipulation macroinstructions
nvmOPCODE(FINDBITSET,		"find.bit",			T_NO_ARG_INST,				0xa0,		OP_TYPE_NTERM|OP_MACRO|MACRO_FINDBITSET,												"find|Bit manipulation||||Return position of the first set bit in the top value of the stack")
nvmOPCODE(MFINDBITSET,		"mfind.bit",		T_NO_ARG_INST,				0xa1,		OP_TYPE_NTERM|OP_MACRO|MACRO_MFINDBITSET,												"find|Bit manipulation||||Return position fof the first set bit in the top value of the stack, with mask")
nvmOPCODE(XFINDBITSET,		"xfind.bit",		T_1BYTE_ARG_INST,			0xa2,		OP_TYPE_NTERM|OP_MACRO|MACRO_XFINDBITSET,												"find|Bit manipulation||||Return position fof the first set bit in the last top values of the stack")
nvmOPCODE(XMFINDBITSET,		"xmfind.bit",		T_1BYTE_ARG_INST,			0xa3,		OP_TYPE_NTERM|OP_MACRO|MACRO_XMFINDBITSET,												"find|Bit manipulation||||Return position fof the first set bit in the last top values of the stack, with mask")
nvmOPCODE(SETBIT,			"set.bit",			T_NO_ARG_INST,				0xe4,		OP_TYPE_STMT|OP_MACRO|MACRO_SETBIT,														"bit|Bit manipulation||||Set the bit at the position specified by the top value of the stack of the second element on the top of the stack")
nvmOPCODE(CLEARBIT,			"clear.bit",		T_NO_ARG_INST,				0xe5,		OP_TYPE_STMT|OP_MACRO|MACRO_CLEARBIT,													"bit|Bit manipulation||||Clear the bit at the position specified by the top value of the stack of the second element on the top of the stack")
nvmOPCODE(FLIPBIT,			"flip.bit",			T_NO_ARG_INST,				0xe6,		OP_TYPE_STMT|OP_MACRO|MACRO_FLIPBIT,													"bit|Bit manipulation||||Flip the bit at the position specified by the top value of the stack of the second element on the top of the stack")
nvmOPCODE(TESTBIT,			"test.bit",			T_NO_ARG_INST,				0xe7,		OP_TYPE_STMT|OP_MACRO|MACRO_TESTBIT,													"bit|Bit manipulation||||Test if the bit at the position specified by the top value of the stack of the second element on the top of the stack and push its value on the stack")
nvmOPCODE(TESTNBIT,			"testn.bit",		T_NO_ARG_INST,				0xe8,		OP_TYPE_NTERM|OP_MACRO|MACRO_TESTNBIT,													"bit|Bit manipulation||||Flip the bit at the position specified by the top value of the stack of the second element n the top of the stack and push its value on the stack")
nvmOPCODE(CLZ,				"clz",				T_NO_ARG_INST,				0xaf,		OP_TYPE_NTERM|OP_MACRO|MACRO_CLZ,														"clz|Bit manipulation||||Count the consecutive number of zeros starting from the MSB")

//Hashing
nvmOPCODE(HASH32,			"hash.32",			T_NO_ARG_INST,				0xfa,		OP_TYPE_NTERM|OP_HASH|HASH_HASH32,														"hash|Hashing|Calculates the 32 bit hash of the the data on the stack||value --> result|Computes a 32 bit hash on a single value on top of the stack")
nvmOPCODE(HASH,				"hash",				T_1BYTE_ARG_INST,			0xfb,		OP_TYPE_NTERM|OP_HASH|HASH_HASH,														"hash|Hashing|||value1, (...), (value n) --> result|Computes a hash on the N topmost values of the stack")





//Checksum calculation and update
nvmOPCODE(CHKSUMADD,		"chksum.add",		T_NO_ARG_INST,				0xd1,		OP_TYPE_NTERM|OP_CHKSM|CHKSM_CHKSUMADD,													"chksum|Checksum calculation||||Update a checksum from stack adding a 16 bit value taken from stack")
nvmOPCODE(CHKSUMSUB,		"chksum.sub",		T_NO_ARG_INST,				0xd2,		OP_TYPE_NTERM|OP_CHKSM|CHKSM_CHKSUMSUB,													"chksum|Checksum calculation||||Update a checksum from stack subtracting a 16 bit value taken from stack")
nvmOPCODE(CHKSUMCALCPKT,	"chksum.calc",		T_NO_ARG_INST,				0xd3,		OP_TYPE_NTERM|OP_CHKSM|CHKSM_CHKSUMCALCPKT,												"chksum|Checksum calculation||||Calculate the checksum as specyfied by RFC 1071 taking values from packet buffer")
nvmOPCODE(JUMPCHECKSUM,		"chksum.jump",		T_1_SHORT_LABEL_INST,		0xd4,		OP_TYPE_STMT|OP_CHKSM|CHKSM_JUMPCHECKSUM,												"chksum|Checksum calculation||||Calculate the checksum as specyfied by RFC 1071 and branch if the result is 0xffff")
nvmOPCODE(CRCCALC,			"crc.calc",			T_1BYTE_ARG_INST,			0xd5,		OP_TYPE_NTERM|OP_CHKSM|CHKSM_CHKSUMADD,													"crc|Checksum calculation||||Calculate the specified CRC for the top value of the stack")
nvmOPCODE(CRCCALCPKT,		"crc.calcpkt",		T_1BYTE_ARG_INST,			0xd0,		OP_TYPE_NTERM|OP_CHKSM|CHKSM_CHKSUMADD,													"crc|Checksum calculation||||Calculate the specified CRC for a buffer inside packet buffer")

//locals management
nvmOPCODE(LOCLD,			"locload",			T_1INT_ARG_INST,			0xd9,		OP_TYPE_TERM|OP_LOC|LOC_LOCLD|NO_OPS|ONE_DEF,											"locld|Locals management|Copies the value of the local variable indexed by the parameter on the top of the stack|The stack is full (no value can be pushed on the stack) or there is not a local variable to load| (none) -> value |")
nvmOPCODE(LOCST,			"locstore",			T_1INT_ARG_INST,			0xda,		OP_TYPE_STMT|OP_LOC|LOC_LOCST|ONE_OP|ONE_DEF,											"locst|Locals management|Stores the value on top of the stack in the given local variable|The stack is empty (i.e., no elements can be popped out from the stack); the memory allocated for local variables is full| value ---> (none) |")

// Coprocessor interaction
nvmOPCODE(COPINIT,			"copro.init",		T_COPRO_INIT_INST,			0xfd,		OP_TYPE_STMT|OP_COP|COP_COPINIT|NO_OPS|ONE_DEF,											"copro.init|Coprocessor interaction|Call coprocessor initialisation function|No such coprocessor exists| value -> result |Call coprocessor initialisation function; the second parameter is coprocessor-dependent")
nvmOPCODE(COPIN,			"copro.in",			T_2_COPRO_IO_ARG_INST,		0xf8,		OP_TYPE_STMT|OP_COP|COP_COPIN|NO_OPS|ONE_DEF,											"copro.in|Coprocessor interaction|Read a value from a coprocessor register|No such coprocessor exists; the coprocessor has no such register| (none) -> value |Read a value from a coprocessor register")
nvmOPCODE(COPOUT,			"copro.out",		T_2_COPRO_IO_ARG_INST,		0xf9,		OP_TYPE_STMT|OP_COP|COP_COPOUT|ONE_OP|NO_DEF,											"copro.out|Coprocessor interaction|Write a value to a coprocessor register|No such coprocessor exists; the coprocessor has no such register| value -> (none) |Write a value to a coprocessor register")
nvmOPCODE(COPRUN,			"copro.invoke",		T_2_COPRO_IO_ARG_INST,		0xfc,		OP_TYPE_STMT|OP_COP|COP_COPRUN|NO_OPS|NO_DEF,											"copro.invoke|Coprocessor interaction|Invoke execution of a coprocessor|No such coprocessor exists; exception generated from coprocessor execution| (none) |Invoke execution of a coprocessor")
nvmOPCODE(COPPKTOUT,		"copro.exbuf",		T_2_COPRO_IO_ARG_INST,		0xfe,		OP_TYPE_STMT|OP_COP|COP_COPRUN|NO_OPS|NO_DEF,											"copro.exbuf|Coprocessor interaction|Transfer the ownership of the current exchange buffer to a coprocessor. First parameter is the coprocessor name, while the second parameter is not currently used and should set to zero.|No such coprocessor exists; exception generated from coprocessor execution| (none) |Pass the exchange buffer to a coprocessor")
//nvmOPCODE(COPPKTOUT,		"copro.exbuf",		T_2_COPRO_IO_ARG_INST,		0xfe,		OP_TYPE_STMT|OP_COP|COP_COPRUN|NO_OPS|NO_DEF,											"copro.invoke|Coprocessor interaction|Transfer the ownership of the current exchange buffer to a coprocessor. First parameter is the coprocessor name, while the second parameter is not currently used and should set to zero.|No such coprocessor exists; exception generated from coprocessor execution| (none) |Pass the exchange buffer to a coprocessor")
