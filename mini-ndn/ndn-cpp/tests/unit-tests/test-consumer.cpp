/**
 * Copyright (C) 2016-2018 Regents of the University of California.
 * @author: Jeff Thompson <jefft0@remap.ucla.edu>
 * @author: From ndn-group-encrypt unit tests
 * https://github.com/named-data/ndn-group-encrypt/blob/master/tests/unit-tests/producer.t.cpp
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version, with the additional exemption that
 * compiling, linking, and/or using OpenSSL is allowed.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * A copy of the GNU Lesser General Public License is in the file COPYING.
 */

#include "gtest/gtest.h"
#include <algorithm>
#include <fstream>
#include <stdexcept>
#include <ndn-cpp/security/identity/memory-identity-storage.hpp>
#include <ndn-cpp/security/identity/memory-private-key-storage.hpp>
#include <ndn-cpp/security/policy/no-verify-policy-manager.hpp>
#include <ndn-cpp/security/key-chain.hpp>
#include <ndn-cpp/encrypt/algo/rsa-algorithm.hpp>
#include <ndn-cpp/encrypt/algo/encryptor.hpp>
#include <ndn-cpp/encrypt/sqlite3-consumer-db.hpp>
#include <ndn-cpp/encrypt/consumer.hpp>

using namespace std;
using namespace ndn;
using namespace ndn::func_lib;

static bool
fileExists(const string& filePath)
{
  ifstream stream(filePath.c_str());
  bool result = (bool)stream;
  stream.close();
  return result;
}

static string
getPolicyConfigDirectory()
{
  string policyConfigDirectory = "policy_config";
  // Check if expected files are in this directory.
  if (!fileExists(policyConfigDirectory + "/regex_ruleset.conf")) {
    // Maybe we are running "make check" from the ndn-cpp root.  There may be
    //   a way to tell "make check" to run from tests/unit-tests, but for
    //   now just set policyConfigDirectory explicitly.
    policyConfigDirectory = "tests/unit-tests/policy_config";

    if(!fileExists(policyConfigDirectory + "/regex_ruleset.conf"))
      throw runtime_error("Cannot find the directory for policy-config");
  }

  return policyConfigDirectory;
}

static uint8_t DATA_CONTENT[] = {
  0xcb, 0xe5, 0x6a, 0x80, 0x41, 0x24, 0x58, 0x23,
  0x84, 0x14, 0x15, 0x61, 0x80, 0xb9, 0x5e, 0xbd,
  0xce, 0x32, 0xb4, 0xbe, 0xbc, 0x91, 0x31, 0xd6,
  0x19, 0x00, 0x80, 0x8b, 0xfa, 0x00, 0x05, 0x9c
};

static uint8_t AES_KEY[] = {
  0xdd, 0x60, 0x77, 0xec, 0xa9, 0x6b, 0x23, 0x1b,
  0x40, 0x6b, 0x5a, 0xf8, 0x7d, 0x3d, 0x55, 0x32
};

static uint8_t INITIAL_VECTOR[] = {
  0x73, 0x6f, 0x6d, 0x65, 0x72, 0x61, 0x6e, 0x64,
  0x6f, 0x6d, 0x76, 0x65, 0x63, 0x74, 0x6f, 0x72
};

static uint8_t DEFAULT_RSA_PUBLIC_KEY_DER[] = {
  0x30, 0x82, 0x01, 0x22, 0x30, 0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d, 0x01, 0x01,
  0x01, 0x05, 0x00, 0x03, 0x82, 0x01, 0x0f, 0x00, 0x30, 0x82, 0x01, 0x0a, 0x02, 0x82, 0x01, 0x01,
  0x00, 0xd4, 0x4f, 0xd9, 0xae, 0x7a, 0xd2, 0x87, 0x80, 0x67, 0x11, 0x31, 0xb8, 0x5b, 0xac, 0x8b,
  0x5f, 0xf2, 0x21, 0x28, 0x2c, 0x70, 0xec, 0x66, 0xe9, 0x18, 0xee, 0x5e, 0xf1, 0xe3, 0xef, 0x09,
  0xcb, 0x5e, 0xe0, 0xcd, 0xe4, 0x39, 0x6a, 0x3f, 0x43, 0x2a, 0x3e, 0x1a, 0x06, 0xf2, 0xcc, 0xb0,
  0x0f, 0x5b, 0xd8, 0xa1, 0x3f, 0x1c, 0xb8, 0xfa, 0x8c, 0xa4, 0xbf, 0xa0, 0x57, 0x61, 0xcb, 0x35,
  0xa9, 0x0f, 0x56, 0x76, 0x57, 0x05, 0xa4, 0x56, 0x90, 0x64, 0x3d, 0x0e, 0x6e, 0x24, 0x43, 0x5e,
  0x54, 0x02, 0x99, 0x5b, 0xbe, 0x05, 0xab, 0xc9, 0xfb, 0xb7, 0x8f, 0x17, 0xcb, 0x59, 0xc0, 0x42,
  0x47, 0x79, 0xb1, 0xb8, 0x5c, 0x97, 0xef, 0xab, 0x65, 0x21, 0x88, 0xbd, 0x58, 0x3e, 0x9a, 0x8e,
  0x77, 0x84, 0x6c, 0x3d, 0x1a, 0x71, 0x7a, 0xb5, 0x9b, 0xc4, 0xde, 0xe5, 0x24, 0x18, 0x62, 0x61,
  0x58, 0x40, 0x14, 0x65, 0x6d, 0x8f, 0xa4, 0x82, 0x3e, 0xbe, 0xe9, 0x7a, 0xfa, 0x54, 0x9d, 0x9a,
  0xd3, 0x93, 0x44, 0x5c, 0x62, 0x9a, 0x26, 0x5e, 0x6b, 0x4c, 0xb5, 0x15, 0xe4, 0xe9, 0x4b, 0x4f,
  0x06, 0xd7, 0x59, 0x46, 0xfc, 0x4b, 0x3e, 0x09, 0x01, 0x0b, 0xd4, 0xa8, 0xcb, 0x39, 0x15, 0x4d,
  0x05, 0x0f, 0x3f, 0x08, 0x51, 0x8e, 0x3a, 0x20, 0x7e, 0xb3, 0x01, 0x7b, 0xe0, 0xeb, 0x3d, 0x62,
  0xdc, 0x0a, 0x9e, 0x63, 0x57, 0xcd, 0x68, 0xd8, 0xbe, 0xff, 0x3e, 0x3c, 0x33, 0x6c, 0x0d, 0xd8,
  0xb5, 0x4e, 0xdf, 0xeb, 0xef, 0x3b, 0x7d, 0xba, 0x32, 0xc0, 0x53, 0x48, 0x7e, 0x77, 0x91, 0xc7,
  0x7a, 0x2d, 0xb8, 0xaf, 0x8b, 0xe7, 0x8c, 0x0e, 0xa9, 0x39, 0x49, 0xdc, 0xa5, 0x4e, 0x7d, 0x3b,
  0xc9, 0xbf, 0x18, 0x41, 0x5e, 0xc0, 0x55, 0x4f, 0x90, 0x66, 0xfb, 0x19, 0xc8, 0x4b, 0x11, 0x93,
  0xff, 0x02, 0x03, 0x01, 0x00, 0x01
};

static uint8_t DEFAULT_RSA_PRIVATE_KEY_DER[] = {
  0x30, 0x82, 0x04, 0xa4, 0x02, 0x01,
  0x00, 0x02, 0x82, 0x01, 0x01, 0x00, 0xd4, 0x4f, 0xd9, 0xae, 0x7a, 0xd2, 0x87, 0x80, 0x67, 0x11,
  0x31, 0xb8, 0x5b, 0xac, 0x8b, 0x5f, 0xf2, 0x21, 0x28, 0x2c, 0x70, 0xec, 0x66, 0xe9, 0x18, 0xee,
  0x5e, 0xf1, 0xe3, 0xef, 0x09, 0xcb, 0x5e, 0xe0, 0xcd, 0xe4, 0x39, 0x6a, 0x3f, 0x43, 0x2a, 0x3e,
  0x1a, 0x06, 0xf2, 0xcc, 0xb0, 0x0f, 0x5b, 0xd8, 0xa1, 0x3f, 0x1c, 0xb8, 0xfa, 0x8c, 0xa4, 0xbf,
  0xa0, 0x57, 0x61, 0xcb, 0x35, 0xa9, 0x0f, 0x56, 0x76, 0x57, 0x05, 0xa4, 0x56, 0x90, 0x64, 0x3d,
  0x0e, 0x6e, 0x24, 0x43, 0x5e, 0x54, 0x02, 0x99, 0x5b, 0xbe, 0x05, 0xab, 0xc9, 0xfb, 0xb7, 0x8f,
  0x17, 0xcb, 0x59, 0xc0, 0x42, 0x47, 0x79, 0xb1, 0xb8, 0x5c, 0x97, 0xef, 0xab, 0x65, 0x21, 0x88,
  0xbd, 0x58, 0x3e, 0x9a, 0x8e, 0x77, 0x84, 0x6c, 0x3d, 0x1a, 0x71, 0x7a, 0xb5, 0x9b, 0xc4, 0xde,
  0xe5, 0x24, 0x18, 0x62, 0x61, 0x58, 0x40, 0x14, 0x65, 0x6d, 0x8f, 0xa4, 0x82, 0x3e, 0xbe, 0xe9,
  0x7a, 0xfa, 0x54, 0x9d, 0x9a, 0xd3, 0x93, 0x44, 0x5c, 0x62, 0x9a, 0x26, 0x5e, 0x6b, 0x4c, 0xb5,
  0x15, 0xe4, 0xe9, 0x4b, 0x4f, 0x06, 0xd7, 0x59, 0x46, 0xfc, 0x4b, 0x3e, 0x09, 0x01, 0x0b, 0xd4,
  0xa8, 0xcb, 0x39, 0x15, 0x4d, 0x05, 0x0f, 0x3f, 0x08, 0x51, 0x8e, 0x3a, 0x20, 0x7e, 0xb3, 0x01,
  0x7b, 0xe0, 0xeb, 0x3d, 0x62, 0xdc, 0x0a, 0x9e, 0x63, 0x57, 0xcd, 0x68, 0xd8, 0xbe, 0xff, 0x3e,
  0x3c, 0x33, 0x6c, 0x0d, 0xd8, 0xb5, 0x4e, 0xdf, 0xeb, 0xef, 0x3b, 0x7d, 0xba, 0x32, 0xc0, 0x53,
  0x48, 0x7e, 0x77, 0x91, 0xc7, 0x7a, 0x2d, 0xb8, 0xaf, 0x8b, 0xe7, 0x8c, 0x0e, 0xa9, 0x39, 0x49,
  0xdc, 0xa5, 0x4e, 0x7d, 0x3b, 0xc9, 0xbf, 0x18, 0x41, 0x5e, 0xc0, 0x55, 0x4f, 0x90, 0x66, 0xfb,
  0x19, 0xc8, 0x4b, 0x11, 0x93, 0xff, 0x02, 0x03, 0x01, 0x00, 0x01, 0x02, 0x82, 0x01, 0x00, 0x0f,
  0xa1, 0x85, 0x5c, 0x44, 0x2c, 0xa5, 0xcf, 0x3d, 0x47, 0x55, 0xca, 0xc5, 0xed, 0x11, 0x21, 0xd2,
  0x38, 0xc0, 0xb5, 0x6c, 0xe6, 0xea, 0xb8, 0xb4, 0x9e, 0x30, 0x1d, 0x4c, 0xf3, 0xb7, 0x5b, 0xe2,
  0xb3, 0x58, 0x55, 0x3a, 0x28, 0xe9, 0x59, 0x6f, 0x8d, 0xbc, 0xea, 0xd0, 0x0b, 0x63, 0xd6, 0xed,
  0xa3, 0x28, 0x53, 0xf6, 0x30, 0x64, 0x39, 0xe0, 0x93, 0x3f, 0x21, 0xcf, 0xd0, 0x5f, 0x36, 0x00,
  0x2c, 0x14, 0x70, 0x59, 0xb8, 0xfc, 0xaa, 0x8a, 0xc6, 0xb7, 0xfe, 0x41, 0xeb, 0x37, 0xd1, 0xa5,
  0x93, 0x56, 0xde, 0xc9, 0x9a, 0x19, 0x37, 0xd0, 0x0e, 0xd7, 0xe8, 0x9f, 0xc5, 0xf8, 0xdb, 0x3c,
  0x49, 0x6a, 0x52, 0x5e, 0xd9, 0x45, 0x5c, 0x1f, 0xb8, 0xea, 0x7f, 0xc9, 0xb4, 0x25, 0x53, 0x05,
  0x4b, 0xd6, 0xbf, 0xd0, 0xa5, 0x01, 0x23, 0xe3, 0xbd, 0xa9, 0x4f, 0x1c, 0x00, 0x7a, 0x3c, 0x1b,
  0xbb, 0xaa, 0x08, 0xd9, 0xd2, 0x8c, 0xdb, 0xb4, 0x6c, 0xff, 0x57, 0x64, 0x82, 0xbb, 0x02, 0x71,
  0x2d, 0x99, 0xea, 0x8a, 0x4e, 0x5a, 0xdb, 0x82, 0x20, 0x32, 0x51, 0xf8, 0x30, 0x98, 0x67, 0x4a,
  0x31, 0x73, 0xb1, 0xd7, 0x51, 0xc5, 0x71, 0x82, 0x2b, 0x99, 0xbc, 0x0c, 0xfa, 0x24, 0x4c, 0x0b,
  0x38, 0x73, 0xd8, 0xef, 0x6f, 0x5b, 0xda, 0x56, 0xc8, 0x6b, 0xcb, 0xf5, 0xc6, 0xaa, 0x4d, 0x8b,
  0x39, 0x0f, 0x0a, 0x43, 0x4e, 0x8b, 0x87, 0xe7, 0x98, 0x5a, 0x0d, 0x94, 0x55, 0xc7, 0x42, 0xb4,
  0x13, 0xfa, 0xed, 0x9c, 0xfe, 0xea, 0x2d, 0x95, 0xc1, 0xdc, 0x2f, 0x5d, 0x44, 0xf5, 0x2d, 0xab,
  0x8b, 0x79, 0x70, 0x0f, 0xe9, 0xa7, 0x17, 0xe8, 0x40, 0xd7, 0xa5, 0x0d, 0x97, 0xe9, 0x53, 0xa4,
  0xb4, 0x70, 0xbe, 0x19, 0x7b, 0x86, 0x2c, 0x26, 0xe7, 0xb1, 0x23, 0x22, 0x5a, 0xbd, 0x91, 0x02,
  0x81, 0x81, 0x00, 0xe2, 0x4d, 0x3c, 0xdc, 0x23, 0xb5, 0x2d, 0xc4, 0x66, 0xe7, 0xf2, 0xa4, 0x33,
  0xb9, 0xd6, 0xdd, 0x39, 0xc6, 0xee, 0x0e, 0xe6, 0x23, 0xbb, 0x9c, 0xf0, 0x6a, 0x10, 0xa8, 0x12,
  0xaa, 0x15, 0x8c, 0x08, 0x51, 0x5d, 0xed, 0x46, 0x33, 0xb0, 0x5d, 0x72, 0x02, 0xa0, 0x16, 0xb8,
  0xcf, 0xaa, 0x27, 0x09, 0x74, 0x97, 0x8c, 0xac, 0x8d, 0x4e, 0xbc, 0xe8, 0x62, 0xe5, 0x1e, 0x3c,
  0x74, 0xbb, 0xe9, 0xb9, 0xa6, 0x91, 0x02, 0x3f, 0x43, 0x4d, 0x2f, 0x01, 0x2a, 0x1c, 0xff, 0x4f,
  0x05, 0xf5, 0x98, 0x57, 0x3f, 0x67, 0xb0, 0x2d, 0x84, 0x2d, 0xd3, 0xf5, 0xb9, 0xd7, 0x37, 0x39,
  0x2a, 0x44, 0x04, 0x58, 0xa4, 0x17, 0x1e, 0x47, 0x38, 0x3f, 0x7d, 0x61, 0x97, 0xf2, 0xe4, 0xe5,
  0xeb, 0xe8, 0xbf, 0x55, 0xac, 0x6b, 0x74, 0xb8, 0x55, 0x2b, 0x1c, 0x12, 0x2a, 0x9c, 0x11, 0xf0,
  0x5b, 0x9d, 0xd7, 0x02, 0x81, 0x81, 0x00, 0xf0, 0x2c, 0x9d, 0xa3, 0x34, 0x0b, 0x6a, 0x01, 0x69,
  0x6c, 0xaa, 0xbf, 0xee, 0x95, 0xcc, 0x12, 0x24, 0x37, 0xeb, 0xda, 0x30, 0xdb, 0xe5, 0x4b, 0x34,
  0x5b, 0x56, 0x9e, 0x46, 0xeb, 0xe5, 0xb5, 0x75, 0x45, 0xac, 0xb7, 0xa2, 0x52, 0x69, 0x04, 0xd2,
  0x5f, 0x98, 0x59, 0x4f, 0xb6, 0xf3, 0x8e, 0x9f, 0x34, 0x8d, 0x07, 0x22, 0x7e, 0xc0, 0x28, 0x79,
  0xe1, 0x25, 0x0a, 0x03, 0x96, 0xb8, 0xa8, 0x0f, 0xc8, 0x37, 0x2d, 0xb0, 0xe8, 0xc0, 0x1e, 0x3b,
  0x4a, 0xf2, 0xcc, 0x6b, 0x60, 0x83, 0x88, 0x2d, 0x71, 0x8f, 0x91, 0xab, 0x1a, 0x02, 0x8e, 0x03,
  0xfb, 0xc2, 0x9a, 0x4e, 0x91, 0xd4, 0x49, 0x2c, 0x4c, 0x69, 0x8c, 0xe9, 0x4b, 0xbe, 0x88, 0xe2,
  0xd9, 0xa8, 0x7f, 0x3d, 0xe9, 0x67, 0x39, 0xd7, 0xd4, 0x11, 0xa0, 0xb1, 0xcd, 0x8b, 0x59, 0x5f,
  0xce, 0x35, 0x16, 0x26, 0x30, 0xe6, 0x19, 0x02, 0x81, 0x81, 0x00, 0x9b, 0x59, 0x44, 0x47, 0x26,
  0xa8, 0x10, 0x63, 0xfb, 0xf4, 0x8c, 0x27, 0xd6, 0x6e, 0x63, 0xa6, 0x78, 0x2c, 0x2c, 0x6d, 0xc3,
  0xe4, 0x91, 0xbd, 0x39, 0x78, 0xc6, 0x38, 0x6a, 0x9f, 0xa1, 0xad, 0x00, 0x64, 0xc2, 0xe2, 0xc8,
  0x47, 0x61, 0x71, 0xb4, 0x7b, 0x42, 0xe4, 0x76, 0x37, 0xf0, 0x69, 0x5d, 0xdf, 0x50, 0xcd, 0xbc,
  0x02, 0x41, 0x24, 0x03, 0x2f, 0x28, 0x73, 0xaa, 0x32, 0xc4, 0x70, 0xbd, 0x06, 0x30, 0x13, 0x67,
  0xd4, 0x4e, 0x9e, 0xce, 0xe0, 0xd7, 0x09, 0x18, 0x79, 0x51, 0xd0, 0x23, 0x4c, 0x9e, 0x64, 0x5d,
  0xca, 0x98, 0x1f, 0x22, 0x57, 0x51, 0xfb, 0x51, 0xdd, 0xc6, 0xd5, 0x68, 0xf8, 0x33, 0xfa, 0x90,
  0x0f, 0x77, 0xde, 0x1d, 0x69, 0xce, 0xce, 0xfd, 0x5b, 0x05, 0xea, 0x9a, 0xe8, 0x82, 0xd7, 0x9c,
  0x56, 0xb3, 0x02, 0x51, 0x22, 0x39, 0x03, 0x43, 0x89, 0xd0, 0xff, 0x02, 0x81, 0x80, 0x13, 0x1c,
  0x89, 0xc2, 0xb5, 0xde, 0x7e, 0xa5, 0xf4, 0x1c, 0xa8, 0x8d, 0xb3, 0x4f, 0x8a, 0x38, 0x9b, 0x57,
  0x33, 0xd6, 0x5d, 0xf2, 0xf1, 0x91, 0x05, 0x6e, 0x8b, 0x3a, 0xf7, 0x0b, 0xc8, 0x70, 0xa3, 0x0f,
  0x53, 0x4a, 0x1d, 0x89, 0x8f, 0x3f, 0xc9, 0xf9, 0xbf, 0x66, 0xc3, 0xf8, 0x1b, 0xf3, 0x6a, 0x69,
  0xc5, 0x1b, 0x1f, 0x3c, 0x94, 0xcf, 0xe3, 0xba, 0xed, 0xb6, 0x99, 0x48, 0x82, 0x13, 0x25, 0x86,
  0x5a, 0x15, 0xb1, 0xb1, 0x23, 0xb0, 0x84, 0x29, 0x57, 0x9e, 0xba, 0xa0, 0xa8, 0x76, 0xca, 0x9e,
  0xf1, 0xbc, 0xb6, 0xaf, 0xd0, 0x2a, 0x3a, 0xd8, 0xea, 0xc8, 0x5a, 0x9e, 0x32, 0x15, 0x4c, 0x88,
  0x1c, 0x12, 0x11, 0x72, 0x6c, 0x8b, 0xf9, 0xf9, 0x35, 0xf6, 0x42, 0x17, 0xf3, 0x95, 0xdf, 0xbd,
  0xc9, 0x55, 0x4f, 0x30, 0xba, 0xf8, 0xf6, 0xad, 0xb2, 0xfd, 0xbb, 0x36, 0x42, 0xe9, 0x02, 0x81,
  0x81, 0x00, 0xad, 0xf0, 0xc0, 0xfc, 0x55, 0x47, 0x8a, 0x03, 0x2b, 0x5c, 0x1c, 0x6e, 0xef, 0xf6,
  0x96, 0x68, 0xee, 0xa8, 0xd0, 0x6d, 0x70, 0x4f, 0x7f, 0x3e, 0x17, 0x2b, 0xfd, 0x7e, 0x22, 0x8c,
  0xea, 0x25, 0xe3, 0xbb, 0xa4, 0xa1, 0x57, 0xe7, 0x3e, 0xc0, 0x47, 0xf8, 0x7b, 0xa6, 0xd2, 0x48,
  0x68, 0xc0, 0x8a, 0xe0, 0xb2, 0x6b, 0x5d, 0xf9, 0x32, 0x6e, 0x70, 0x5a, 0xb9, 0x77, 0xd9, 0xbf,
  0x6d, 0xea, 0x53, 0xe2, 0x4f, 0xa8, 0x4c, 0x1c, 0xfa, 0x69, 0x49, 0x26, 0x48, 0x8a, 0xc5, 0x92,
  0x77, 0x6b, 0x7a, 0x89, 0xc3, 0xef, 0x6d, 0x1c, 0x44, 0x10, 0xe6, 0xaf, 0x47, 0x18, 0x9f, 0x99,
  0x09, 0xb4, 0x3b, 0x63, 0xf7, 0xbf, 0xe4, 0xe7, 0xe5, 0x98, 0xe2, 0x57, 0x85, 0xbb, 0x78, 0xb5,
  0xd1, 0xc3, 0x64, 0x8d, 0x4d, 0x4f, 0x02, 0xdb, 0x2c, 0x51, 0x58, 0xa3, 0xc7, 0x35, 0xf1, 0x2d,
  0x7a, 0x0a
};

class TestConsumer : public ::testing::Test {
public:
  TestConsumer()
  {
    string policyConfigDirectory = getPolicyConfigDirectory();

    databaseFilePath = policyConfigDirectory + "/test.db";
    remove(databaseFilePath.c_str());

    groupName = Name("/Prefix/READ");
    contentName = Name("/Prefix/SAMPLE/Content");
    cKeyName = Name("/Prefix/SAMPLE/Content/C-KEY/1");
    eKeyName = Name("/Prefix/READ/E-KEY/1/2");
    dKeyName = Name("/Prefix/READ/D-KEY/1/2");
    uKeyName = Name("/U/Key");
    uName = Name("/U");

    // Generate the E-KEY and D-KEY.
    RsaKeyParams params;
    fixtureDKeyBlob = RsaAlgorithm::generateKey(params).getKeyBits();
    fixtureEKeyBlob = RsaAlgorithm::deriveEncryptKey(fixtureDKeyBlob).getKeyBits();

    // Generate the user key.
    fixtureUDKeyBlob = RsaAlgorithm::generateKey(params).getKeyBits();
    fixtureUEKeyBlob = RsaAlgorithm::deriveEncryptKey(fixtureUDKeyBlob).getKeyBits();

    // Load the C-KEY.
    fixtureCKeyBlob = Blob(AES_KEY, sizeof(AES_KEY));

    // Set up the keyChain.
    ptr_lib::shared_ptr<MemoryIdentityStorage> identityStorage
      (new MemoryIdentityStorage());
    ptr_lib::shared_ptr<MemoryPrivateKeyStorage> privateKeyStorage
      (new MemoryPrivateKeyStorage());
    keyChain.reset(new KeyChain
      (ptr_lib::make_shared<IdentityManager>(identityStorage, privateKeyStorage),
       ptr_lib::make_shared<NoVerifyPolicyManager>()));

    // Initialize the storage.
    Name identityName("TestConsumer");
    Name keyName("/testname/DSK-123");
    certificateName = keyName.getSubName(0, keyName.size() - 1).append
      ("KEY").append(keyName.get(-1)).append("ID-CERT").append("0");
    identityStorage->addKey
      (keyName, KEY_TYPE_RSA, Blob(DEFAULT_RSA_PUBLIC_KEY_DER,
       sizeof(DEFAULT_RSA_PUBLIC_KEY_DER)));
    privateKeyStorage->setKeyPairForKeyName
      (keyName, KEY_TYPE_RSA, DEFAULT_RSA_PUBLIC_KEY_DER,
       sizeof(DEFAULT_RSA_PUBLIC_KEY_DER), DEFAULT_RSA_PRIVATE_KEY_DER,
       sizeof(DEFAULT_RSA_PRIVATE_KEY_DER));
  }

  virtual void
  TearDown()
  {
    remove(databaseFilePath.c_str());
  }

  ptr_lib::shared_ptr<Data>
  createEncryptedContent()
  {
    ptr_lib::shared_ptr<Data> contentData(new Data(contentName));
    EncryptParams encryptParams(ndn_EncryptAlgorithmType_AesCbc);
    encryptParams.setInitialVector(Blob(INITIAL_VECTOR, sizeof(INITIAL_VECTOR)));
    Encryptor::encryptData
      (*contentData, Blob(DATA_CONTENT, sizeof(DATA_CONTENT)), cKeyName,
       fixtureCKeyBlob, encryptParams);
    keyChain->sign(*contentData, certificateName);
    return contentData;
  }

  ptr_lib::shared_ptr<Data>
  createEncryptedCKey()
  {
    ptr_lib::shared_ptr<Data> cKeyData(new Data(cKeyName));
    EncryptParams encryptParams(ndn_EncryptAlgorithmType_RsaOaep);
    Encryptor::encryptData
      (*cKeyData, fixtureCKeyBlob, dKeyName, fixtureEKeyBlob, encryptParams);
    keyChain->sign(*cKeyData, certificateName);
    return cKeyData;
  }

  ptr_lib::shared_ptr<Data>
  createEncryptedDKey()
  {
    ptr_lib::shared_ptr<Data> dKeyData(new Data(dKeyName));
    EncryptParams encryptParams(ndn_EncryptAlgorithmType_RsaOaep);
    Encryptor::encryptData
      (*dKeyData, fixtureDKeyBlob, uKeyName, fixtureUEKeyBlob, encryptParams);
    keyChain->sign(*dKeyData, certificateName);
    return dKeyData;
  }

  void
  onPlainText(const Blob& result, const Blob& expectedResult)
  {
    ASSERT_TRUE(result.equals(expectedResult));
  }

  void
  onError(EncryptError::ErrorCode errorCode, const string& message)
  {
    FAIL() << "onError code " << errorCode << " " << message;
  }

  void
  onConsumeComplete
    (const ptr_lib::shared_ptr<Data>& contentData, const Blob& result,
     int* finalCount)
  {
    (*finalCount) = 1;
    ASSERT_TRUE(result.equals(Blob(DATA_CONTENT, sizeof(DATA_CONTENT))))
      << "consumeComplete";
  }

  string databaseFilePath;

  ptr_lib::shared_ptr<KeyChain> keyChain;
  Name certificateName;

  Blob fixtureCKeyBlob;
  Blob fixtureEKeyBlob;
  Blob fixtureDKeyBlob;
  Blob fixtureUEKeyBlob;
  Blob fixtureUDKeyBlob;

  Name groupName;
  Name contentName;
  Name cKeyName;
  Name eKeyName;
  Name dKeyName;
  Name uKeyName;
  Name uName;
};

TEST_F(TestConsumer, DecryptContent)
{
  // Generate the AES key.
  Blob aesKeyBlob(AES_KEY, sizeof(AES_KEY));

  // Generate the C-KEY packet for the same AES_KEY.
  ptr_lib::shared_ptr<Data> cKeyData = createEncryptedCKey();
  // Generate the content packet.
  ptr_lib::shared_ptr<Data> contentData = createEncryptedContent();

  // Decrypt.
  Consumer::Impl::decrypt
    (cKeyData->getContent(), fixtureDKeyBlob,
     bind(&TestConsumer::onPlainText, this, _1, aesKeyBlob),
     bind(&TestConsumer::onError, this, _1, _2));

  // Decrypt.
  Consumer::Impl::decrypt
    (contentData->getContent(), fixtureCKeyBlob,
     bind(&TestConsumer::onPlainText, this, _1,
          Blob(DATA_CONTENT, sizeof(DATA_CONTENT))),
     bind(&TestConsumer::onError, this, _1, _2));
}

TEST_F(TestConsumer, Consume)
{
  ptr_lib::shared_ptr<Data> contentData = createEncryptedContent();
  ptr_lib::shared_ptr<Data> cKeyData = createEncryptedCKey();
  ptr_lib::shared_ptr<Data> dKeyData = createEncryptedDKey();

  int contentCount = 0;
  int cKeyCount = 0;
  int dKeyCount = 0;

  // Prepare a TestFace to instantly answer calls to expressInterest.
  class TestFace : public Face {
  public:
    TestFace(ptr_lib::shared_ptr<Data> contentData,
             ptr_lib::shared_ptr<Data> cKeyData,
             ptr_lib::shared_ptr<Data> dKeyData,
             int* contentCount, int* cKeyCount, int* dKeyCount)
    : Face("localhost"),
      contentData_(contentData),
      cKeyData_(cKeyData),
      dKeyData_(dKeyData),
      contentCount_(contentCount),
      cKeyCount_(cKeyCount),
      dKeyCount_(dKeyCount)
    {}

    virtual uint64_t
    expressInterest
      (const Interest& interest, const OnData& onData,
       const OnTimeout& onTimeout, const OnNetworkNack& onNetworkNack,
       WireFormat& wireFormat = *WireFormat::getDefaultWireFormat())
    {
      if (interest.matchesName(contentData_->getName())) {
        *contentCount_ = 1;
        onData(ptr_lib::make_shared<Interest>(interest), contentData_);
      }
      else if (interest.matchesName(cKeyData_->getName())) {
        *cKeyCount_ = 1;
        onData(ptr_lib::make_shared<Interest>(interest), cKeyData_);
      }
      else if (interest.matchesName(dKeyData_->getName())) {
        *dKeyCount_ = 1;
        onData(ptr_lib::make_shared<Interest>(interest), dKeyData_);
      }
      else
        onTimeout(ptr_lib::make_shared<Interest>(interest));

      return 0;
    }

  private:
    ptr_lib::shared_ptr<Data> contentData_;
    ptr_lib::shared_ptr<Data> cKeyData_;
    ptr_lib::shared_ptr<Data> dKeyData_;

    int* contentCount_;
    int* cKeyCount_;
    int* dKeyCount_;
  };

  TestFace face
    (contentData, cKeyData, dKeyData, &contentCount, &cKeyCount, &dKeyCount);

  // Create the consumer.
  Consumer consumer
    (&face, keyChain.get(), groupName, uName,
     ptr_lib::make_shared<Sqlite3ConsumerDb>(databaseFilePath));
  consumer.addDecryptionKey(uKeyName, fixtureUDKeyBlob);

  int finalCount = 0;
  consumer.consume
    (contentName,
     bind(&TestConsumer::onConsumeComplete, this, _1, _2, &finalCount),
     bind(&TestConsumer::onError, this, _1, _2));

  ASSERT_EQ(1, contentCount);
  ASSERT_EQ(1, cKeyCount);
  ASSERT_EQ(1, dKeyCount);
  ASSERT_EQ(1, finalCount);
}

TEST_F(TestConsumer, ConsumerWithLink)
{
  ptr_lib::shared_ptr<Data> contentData = createEncryptedContent();
  ptr_lib::shared_ptr<Data> cKeyData = createEncryptedCKey();
  ptr_lib::shared_ptr<Data> dKeyData = createEncryptedDKey();

  int contentCount = 0;
  int cKeyCount = 0;
  int dKeyCount = 0;

  // Prepare a TestFace to instantly answer calls to expressInterest.
  class TestFace : public Face {
  public:
    TestFace(ptr_lib::shared_ptr<Data> contentData,
             ptr_lib::shared_ptr<Data> cKeyData,
             ptr_lib::shared_ptr<Data> dKeyData,
             int* contentCount, int* cKeyCount, int* dKeyCount)
    : Face("localhost"),
      contentData_(contentData),
      cKeyData_(cKeyData),
      dKeyData_(dKeyData),
      contentCount_(contentCount),
      cKeyCount_(cKeyCount),
      dKeyCount_(dKeyCount)
    {}

    virtual uint64_t
    expressInterest
      (const Interest& interest, const OnData& onData,
       const OnTimeout& onTimeout, const OnNetworkNack& onNetworkNack,
       WireFormat& wireFormat = *WireFormat::getDefaultWireFormat())
    {
      if (interest.getLink()->getDelegations().size() != 3)
        throw runtime_error
          ("TestFace::expressInterest: The Interest link does not the expected number of delegates");

      if (interest.matchesName(contentData_->getName())) {
        *contentCount_ = 1;
        onData(ptr_lib::make_shared<Interest>(interest), contentData_);
      }
      else if (interest.matchesName(cKeyData_->getName())) {
        *cKeyCount_ = 1;
        onData(ptr_lib::make_shared<Interest>(interest), cKeyData_);
      }
      else if (interest.matchesName(dKeyData_->getName())) {
        *dKeyCount_ = 1;
        onData(ptr_lib::make_shared<Interest>(interest), dKeyData_);
      }
      else
        onTimeout(ptr_lib::make_shared<Interest>(interest));

      return 0;
    }

  private:
    ptr_lib::shared_ptr<Data> contentData_;
    ptr_lib::shared_ptr<Data> cKeyData_;
    ptr_lib::shared_ptr<Data> dKeyData_;

    int* contentCount_;
    int* cKeyCount_;
    int* dKeyCount_;
  };

  TestFace face
    (contentData, cKeyData, dKeyData, &contentCount, &cKeyCount, &dKeyCount);

  // Create the consumer.
  Link ckeyLink;
  ckeyLink.addDelegation(10,  Name("/ckey1"));
  ckeyLink.addDelegation(20,  Name("/ckey2"));
  ckeyLink.addDelegation(100, Name("/ckey13"));
  Link dkeyLink;
  dkeyLink.addDelegation(10,  Name("/dkey1"));
  dkeyLink.addDelegation(20,  Name("/dkey2"));
  dkeyLink.addDelegation(100, Name("/dkey13"));
  Link dataLink;
  dataLink.addDelegation(10,  Name("/data1"));
  dataLink.addDelegation(20,  Name("/data2"));
  dataLink.addDelegation(100, Name("/data13"));
  keyChain->sign(ckeyLink);
  keyChain->sign(dkeyLink);
  keyChain->sign(dataLink);

  Consumer consumer
    (&face, keyChain.get(), groupName, uName,
     ptr_lib::make_shared<Sqlite3ConsumerDb>(databaseFilePath),
     ckeyLink, dkeyLink);
  consumer.addDecryptionKey(uKeyName, fixtureUDKeyBlob);

  int finalCount = 0;
  consumer.consume
    (contentName,
     bind(&TestConsumer::onConsumeComplete, this, _1, _2, &finalCount),
     bind(&TestConsumer::onError, this, _1, _2), dataLink);

  ASSERT_EQ(1, contentCount);
  ASSERT_EQ(1, cKeyCount);
  ASSERT_EQ(1, dKeyCount);
  ASSERT_EQ(1, finalCount);
}

int
main(int argc, char **argv)
{
  ::testing::InitGoogleTest(&argc, argv);
  return RUN_ALL_TESTS();
}
